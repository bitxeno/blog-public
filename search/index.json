[{"content":"使用 ghproxy 加速 官网：https://mirror.ghproxy.com\n加速方法： 在链接前面添加：https://mirror.ghproxy.com/，如：\nhttps://mirror.ghproxy.com/https://github.com/user/repo/releases/download/version/file 限制：ghproxy 域名可能会被墙，导致需要更换域名\n使用 jsdelivr 加速 官网：https://github.com/jsdelivr/jsdelivr?tab=readme-ov-file#github\n加速方法： 使用 https://cdn.jsdelivr.net/gh 替换 https://github.com 域名，如：\nhttps://cdn.jsdelivr.net/gh/user/repo@version/file @version 可以是 tag 或 commit，省略也可以，如：\nhttps://cdn.jsdelivr.net/gh/user/repo/file 限制：只支持 git 仓库文件，不支持 release 发布的文件\n","date":"2024-02-29T12:16:42+08:00","image":"https://blog.xenori.com/2024/02/github-download-enhance-speed/cover_hu97c93a104dd71fdb6ecb2b1c8317cee1_61791_120x120_fill_box_smart1_3.png","permalink":"https://blog.xenori.com/2024/02/github-download-enhance-speed/","title":"github 下载加速"},{"content":"普通的抓包工具如 charles 等没法抓取unix套接字数据，需要借助 socat 来抓取。\n安装抓包工具 socat brew install socat 制作抓包脚本 在/usr/local/bin下创建一个命名为xdump的 shell 执行脚本，内容如下：\n#!/bin/bash restore(){ mv $1.original $1 echo -e \u0026#34;\\nSocket $1 \\e[33mRESTORED\u0026#34; } sock=\u0026#34;$1\u0026#34; trap \u0026#34;restore $sock\u0026#34; EXIT mv \u0026#34;$sock\u0026#34; \u0026#34;$sock.original\u0026#34; socat -t100 -v UNIX-LISTEN:$sock,mode=777,reuseaddr,fork UNIX-CONNECT:$sock.original 为xdump脚本赋执行权限：\nchmod +x /usr/local/bin/xdump 开始抓包 需要抓包时执行如下命令：\nsudo xdump /path/to/unix_socket_file 例如抓包 xcode 的usbmuxd通信协议：\nsudo xdump /var/run/usbmuxd 输出如下：\n\u0026gt; 2023/05/22 14:17:23.000982894 length=472 from=0 to=471 ........\\b.......\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE plist PUBLIC \u0026#34;-//Apple//DTD PLIST 1.0//EN\u0026#34; \u0026#34;http://www.apple.com/DTDs/PropertyList-1.0.dtd\u0026#34;\u0026gt; \u0026lt;plist version=\u0026#34;1.0\u0026#34;\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;BundleID\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;com.apple.dt.Xcode\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;ClientVersionString\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;usbmuxd-531.100.1\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;MessageType\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;ReadBUID\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;ProcessID\u0026lt;/key\u0026gt; \u0026lt;integer\u0026gt;870\u0026lt;/integer\u0026gt; \u0026lt;key\u0026gt;ProgName\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;Xcode\u0026lt;/string\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;/plist\u0026gt; \u0026lt; 2023/05/22 14:17:23.000985543 length=276 from=0 to=275 ........\\b.......\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE plist PUBLIC \u0026#34;-//Apple//DTD PLIST 1.0//EN\u0026#34; \u0026#34;http://www.apple.com/DTDs/PropertyList-1.0.dtd\u0026#34;\u0026gt; \u0026lt;plist version=\u0026#34;1.0\u0026#34;\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;BUID\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\u0026lt;/string\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;/plist\u0026gt; ","date":"2023-05-22T12:35:10+08:00","image":"https://blog.xenori.com/2023/05/how-to-capture-unix-domain-socket-on-mac/cover_huc84318aa5eda95760760b181358c47b2_188996_120x120_fill_box_smart1_3.png","permalink":"https://blog.xenori.com/2023/05/how-to-capture-unix-domain-socket-on-mac/","title":"Mac系统下如何抓包unix套接字（Unix Domain Socket）"},{"content":"android 9 以上版本，app 不再信任用户安装的证书，只能通过 root 手机把证书移动到 system 分区才能实现抓包。一般日常使用手机为了安全是不可能 root 的，这里通过 Windows 的 WSA 来实现抓包。\n准备环境 到 WSABuilds 下载安装已 root 带 magisk 的 WSA 镜像（假如之前已安装过 WSA，需要先到系统应用列表中，把旧的卸载）\n安装后，开始菜单中搜索 android，找到 WSA 设置应用并打开，选择 开发人员，并打开开发人员模式\n安装APK 安装程序，实现双击安装 apk 和自动安装 adb 命令工具\n安装WSA 工具箱，用于上传文件到 WSA\n下载Magisk app，并安装\n安装 charles 证书 打开 charles，选择菜单 Help -\u0026gt; SSL Proxying -\u0026gt; Save Charles Root Certificate，并选择把证书保存为 .cer 格式\n打开WSA 工具箱，使用文件传输功能把刚刚保存的证书上传到 wsa 的Download目录\n点击WSA 工具箱首页的Android设置，选择安全-\u0026gt;更多安全设置-\u0026gt;加密与凭据-\u0026gt;安装证书菜单，选择并安装Download目录的charles证书\n证书安装成功后，正常在加密与凭据-\u0026gt;信任的凭据-\u0026gt;用户项中能看到已安装的证书 把用户区证书移动到 system 分区 下载 Magisk 的MagiskTrustUserCerts模块压缩包，并通过WSA 工具箱上传到Download目录 打开 Magisk app，点击模块 -\u0026gt; 从本地安装，选择刚刚上传的Download目录下的AlwaysTrustUserCerts压缩包 安装成功后，正常会提示你重启 wsa，没的话，在命令行中执行adb reboot手工重启下\n重启后正常能在加密与凭据-\u0026gt;信任的凭据-\u0026gt;系统中，看到charles证书\n配置代理抓包 打开 charles，选择菜单Proxy -\u0026gt; SSL Proxying Settings...，勾选 Enable SSL Proxying，并添加新的 location，Host填*，Port填443 打开命令行，执行下面的命令设置 WSA 代理： adb connect 127.0.0.1:58526 adb shell settings put global http_proxy 192.168.x.x:8888 其中192.168.x.x需改为charles所在的 ip 地址\n下载安装需要抓包的 app，访问就能在charles看到 https 流量了：） 删除代理 去掉代理需执行下面命令：\nadb shell settings delete global http_proxy adb shell settings delete global global_http_proxy_host adb shell settings delete global global_http_proxy_port ","date":"2023-05-15T15:27:10+08:00","image":"https://blog.xenori.com/2023/05/capture-android-https-network-packet-with-wsa/cover_hu9ac3ef1c7349a5b40b6d5d299feb838d_16021_120x120_fill_q75_box_smart1.jpeg","permalink":"https://blog.xenori.com/2023/05/capture-android-https-network-packet-with-wsa/","title":"通过 WSA 抓取 android 的 https 网络请求包"},{"content":"AppleTV 无法直接安装证书和修改代理，需要借助添加自定义描述文件的方式来实现，才能对 app 进行抓包。\n准备环境 安装 Apple Configurator\n安装 charles\n保证 Mac 和 AppleTV 连接同一局域网\ncharles 配置抓包 https 流量 打开 charles，选择菜单Proxy -\u0026gt; SSL Proxying Settings...，勾选 Enable SSL Proxying，并添加新的 location，Host填*，Port填443 建议把Proxy菜单中的macOS Proxy去掉勾选，避免 Mac 的流量和 AppleTV 的流量混在一起\n创建代理描述文件 打开 charles，选择菜单 Help -\u0026gt; SSL Proxying -\u0026gt; Save Charles Root Certificate，并选择把证书保存为 .cer 格式 打开 Apple configurator，选择菜单 文件 -\u0026gt; 新建描述文件\n点击通用，在名称中填一个易于识别的名称，如charles proxy\n点击证书，并把刚刚保存的 charles root 证书上传上去\n点击Wi-Fi，填上 AppleTV 连接的 wifi 信息和 charles 代理信息\n最后使用快捷键 cmd+s 保存描述文件到本地或 iCloud 中，推荐保存到 iCloud\n在 AppleTV 中添加描述文件 点击 Apple configurator 主菜单，选择配对设备，把 AppleTV 配置并连接上 连接上后，Apple configurator 主界面等一会会显示 AppleTV，右键选择 添加 -\u0026gt; 描述文件，选择刚刚保存的描述文件 等一会 AppleTV 会提示安装描述文件，一路选择安装就可以 安装完成后，会显示刚刚安装的描述文件 进入 AppleTV 设置，选择通用 -\u0026gt; 关于 -\u0026gt; 证书信任设置，把charles证书设置为信任（假如关于中没出现证书信任设置，证明描述文件配置有误，导致描述文件没添加成功） AppleTV 选择系统 -\u0026gt; 重新启动，重启后 AppleTV 会改为使用描述文件中配置的代理 wifi 连接 使用完后可以到菜单通用 -\u0026gt; 描述文件中删除添加的自定义描述文件，删除后连接的 wifi 会丢失断网，需要自已再次手工连接\ncharles 查看 https 流量 等 AppleTV 重启完成，打开想要抓包的 app，在 charles 就能看到 app 的 https 请求了\n参考资料 在Apple TV (tvOS) 上添加描述文件或MitM证书 ","date":"2023-05-14T11:27:10+08:00","image":"https://blog.xenori.com/2023/05/how-capture-appletv-https-network-packet/cover_hu191cf6e70229becaacbb2dfa44e8870a_23104_120x120_fill_q75_h2_box_smart1_2.webp","permalink":"https://blog.xenori.com/2023/05/how-capture-appletv-https-network-packet/","title":"如何抓取 AppleTV (tvOS) 的 https 网络请求包"},{"content":" 文章的部分内容被密码保护：\nJavascript needs to be enabled to decrypt content 2022对很多人来说都是艰难的一年，各地疫情频发，封控层层加码，各种令人气愤的事件不断发生。自上海3月封城疫情后，广州也慢慢进入需要48小时核酸阴性证明的生活。今年因为疫情关系，图书馆很少去了，出门次数也很少，基本都是在家里搞tvOS开发和nas。\n今年开发的三个tvOS应用基本成型，还在考虑是否向苹果交保护费上架App Store或开源。。。对这三个app我是基本满意的，虽然还达不到产品的程度。\n今年还是拖延症严重，没有找工作，简历还没投出一份。。。还是想2023年找到一份正式工作，并把做app等做副业，现在年龄太大了，继续打工的机会基本没了，还是要靠自己。\n2022年年度选择如下：\n年度游戏： 艾尔登法环 很久没这么投入玩一款游戏了，上次还是荒野之息，200+小时，为了结局通了3遍，精美的画面氛围，广阔高自由度的地图，有时间的都推荐玩一下\n年度动画： 赛博朋克：边缘行者 靠动画把游戏的人气再次拉起，前期luci太美了😘\n年度音乐： I Really Want to Stay At Your House 游戏《赛博朋克2077》中的一首开车电台歌曲，之前玩了几百小时都没听到过，靠《赛博朋克：边缘行者》重新带火了，适合配合动画剧情画面一起听\n年度电影（电视剧）： 隐入尘烟 开端 (电视剧) 年度图书： 无\n年度APP： 无\n年度数码： Ulanzi像素桌面时钟 一直想找一个仿lametric的像素时钟，这款基本能满足需求，还能自己开发插件，现在主要用来显示时间和github star数。\n","date":"2023-01-24T11:10:08+08:00","image":"https://blog.xenori.com/2023/01/the-summary-of-2022/cover_hu9a3d999fd7aad1a90e9d3706afaa7886_263248_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.xenori.com/2023/01/the-summary-of-2022/","title":"2022年度总结"},{"content":"1. 切割mkv并保留字幕 # 截取从30s开始的30s视频 ffmpeg -ss 00:00:00 -t 00:00:30 -i input.mkv -c:v copy -c:a copy -c:s copy -map 0 output.mkv ","date":"2022-12-10T11:27:10+08:00","image":"https://blog.xenori.com/2022/12/ffmpeg-commands/cover_hue03b7fb6a8cca6756dd6d28025cc72ea_2169233_120x120_fill_box_smart1_3.png","permalink":"https://blog.xenori.com/2022/12/ffmpeg-commands/","title":"常用ffmpeg命令"},{"content":"媒体文件命名规范 电影 参考：https://jellyfin.org/docs/general/server/media/movies/\nMovies ├── Best_Movie_Ever (2019) │ ├── Best_Movie_Ever (2019) - 1080P.mp4 │ ├── Best_Movie_Ever (2019) - 720P.mp4 │ └── Best_Movie_Ever (2019) - Directors Cut.mp4 └── Movie (2021) [imdbid-tt12801262] ├── Movie (2021) [imdbid-tt12801262] - 2160p.mp4 ├── Movie (2021) [imdbid-tt12801262] - 1080p.mp4 └── Movie (2021) [imdbid-tt12801262] - Directors Cut.mp4 电视剧 参考：https://jellyfin.org/docs/general/server/media/shows\nShows └── Series Name (2010) ├── Season 01 │ ├── Series Name S01E01.mkv │ ├── Series Name S01E02.mkv │ ├── featurettes │ │ └── Some Featurette.mkv │ └── interviews │ └── Interview with the Director.mp4 ├── Season 02 │ ├── Series Name S02E01.mkv │ ├── Series Name S02E02.mkv │ └── behind the scenes │ └── Behind the Scenes.mp4 └── extras └── Fantastic Extra.mkv 解决我的媒体封面图中文变方块 先进入docker shell，安装中文支持字体\napt update apt install fonts-noto-cjk 安装后先删除旧的封面图，然后选择右下角菜单的刷新元数据，这样会再次生成新的封面。\n解决元数据没自动获取 假如nas的影片很多，inotify的监控文件数会到达上限，就会出现这情况。可以在docker的host端，执行命令增大监控文件数：\nsysctl -w fs.inotify.max_user_watches=1048576 然后重启下jellyfin就可以了\n最新添加的剧集不在首页显示 默认是按视频文件创建时间排序的，假如视频文件创建日期太旧就会这样，可到控制台媒体库 -\u0026gt; 显示中，把选项新内容加入的日期改为使用扫描日期\n首页最新的电视剧栏只显示几个 这是jellyfin查找最新电视剧是居于最新剧集来查询导致的，默认只查找前80个剧集，假如最近添加的电视剧的剧集数比较多，就会挤掉其他电视剧导致没法在首页显示。只能等jellyfin修改查询机制修复。issue#1880\n匹配的元数据不正确怎解决？ 可以使用右上角的识别功能重新匹配，假如重新匹配也不正确，可以手工修改元数据，如集号等，再使用刷新元数据 -\u0026gt; 搜索缺少的元数据匹配缺少的元数据。\n","date":"2022-09-27T11:58:08+08:00","image":"https://blog.xenori.com/2022/09/jellyfin-practice/cover_hud6c94798a038d917706e56ba7059c630_23107_120x120_fill_box_smart1_3.png","permalink":"https://blog.xenori.com/2022/09/jellyfin-practice/","title":"jellyfin使用指南"},{"content":"服务器抓包 Mac示例 192.168.1.1是服务器ip，192.168.2.1是Mac ip，本命令在Mac终端执行\nssh root@192.168.1.1 \u0026#39;tcpdump -i br-lan host 192.168.2.1 -s 0 -l -w -\u0026#39; | /Applications/Wireshark.app/Contents/MacOS/Wireshark -k -i - Windows示例 请求过滤 查看http的GET请求 http.request.method == \u0026#34;GET\u0026#34; 查看http所有成功的请求 http.response.code == 200 ","date":"2022-08-10T11:58:08+08:00","image":"https://blog.xenori.com/2022/08/wireshark-commands/cover_hu99c1998a3cbc7febb1b0de042a214370_17044_120x120_fill_box_smart1_3.png","permalink":"https://blog.xenori.com/2022/08/wireshark-commands/","title":"wireshark常用抓包分析命令"},{"content":"焦点非对齐移动 默认tvOS焦点移动是需要移动方向上有能获取焦点的button，假如button是左右靠边对齐的，就移动不上去。需要使用focusSetion把button所在的整行范围变成可焦点识别的，才能自动移动到靠边的button上。\n示例：\nVStack { HStack { Button {} label: { Text(\u0026#34;test\u0026#34;) } } .frame(maxWidth: .infinity, alignment: .trailing) .focusSection() Button {} label: { Text(\u0026#34;Save\u0026#34;) } } 实现Parralw效果 需要使用开源库ParallaxView编写自定义控件实现\n优化滚动列表性能 SwiftUI滚动列表中有异步加载的图片时，向下快速滚动会停顿，不能持续滚动，看着像是tvOS焦点切换到indicator时出现了问题。要解决只能改为使用UICollectionView来实现滚动列表，推荐使用第三方开源的ASCollectionView或SwiftUIX来实现。\ntabbar随内容滚动 需要借助Introspect库\nimport Foundation import SwiftUI struct TabBarScrollModifier: ViewModifier { func body(content: Content) -\u0026gt; some View { content.introspectViewController { viewController in let scrollView = findScrollViewIn(view: viewController.view) if let scrollView = scrollView as? UIScrollView { viewController.setContentScrollView(scrollView, for: .top) } } } private func findScrollViewIn(view : UIView?) -\u0026gt; UIView? { guard let view = view else { return nil } if view.subviews.count \u0026lt;= 0 { return nil } for sub in view.subviews { if sub is UIScrollView || sub is UICollectionView { return sub } if let item = findScrollViewIn(view: sub) { return item } } return nil } } extension View { func tabBarScroll() -\u0026gt; some View { modifier(TabBarScrollModifier()) } } 在内容的ScrollView中调用：\nScrollView { // content } .tabBarScroll() onLongPressGesture导致跳转失效 假如在 NavigationLink 上使用 onLongPressGesture，那么 NavigartionLink 的跳转会失效\nNavigationLink{ EmptyView() } label: { Text(\u0026#34;Click\u0026#34;) } .onLongPressGesture { // 加上这句会没法触发跳转 print(\u0026#34;long press\u0026#34;) } 看网上说法这是appletv的bug，可在 onLongPressGesture 前面加上 onPlayPauseCommand 来避免这问题\nNavigationLink{ EmptyView() } label: { Text(\u0026#34;Click\u0026#34;) } .onPlayPauseCommand { // fixed navigate!!! } .onLongPressGesture { print(\u0026#34;long press\u0026#34;) } 如何本地修改导入的swift package 需要把swift package先下载到本地，然后在finder中找到文件夹，直接拖到xcode项目根目录中\n这样修改本地代码，就可以在xcode中看到修改后的效果\n","date":"2022-06-21T11:58:08+08:00","image":"https://blog.xenori.com/2022/06/tvos-development-practice-with-swiftui/cover_hu5373dfbebd7dcd997d2dd643acf5f496_29876_120x120_fill_box_smart1_3.png","permalink":"https://blog.xenori.com/2022/06/tvos-development-practice-with-swiftui/","title":"tvOS 开发实践 - SwiftUI篇"},{"content":"安装caddy Mac:\nbrew install caddy Windows:\n到官网直接下载：https://caddyserver.com/download\n快速启动支持https的开发服务器 安装证书 caddy trust 启动简单文件服务器 进入文件目录，执行如下命令：\ncaddy file-server 启动开发服务器 进入项目根目录，执行如下命令：\ncat \u0026lt;\u0026lt;EOF \u0026gt; Caddyfile www.example.com { try_files {path} /index.html file_server tls internal } EOF caddy run ","date":"2022-04-20T11:58:08+08:00","image":"https://blog.xenori.com/2022/04/caddy-usage/cover_hucb488979afe6bed39a457371c9aa8b9c_75678_120x120_fill_q75_box_smart1.jpeg","permalink":"https://blog.xenori.com/2022/04/caddy-usage/","title":"caddy使用教程"},{"content":"本来以为2021年新冠影响会慢慢降低，旅游也会逐步开放，但西方世界的拉垮是你想不到的。今年的西方政坛除了不断找各种理由给你使绊子，实在没做什么对世界有益的事。twitter上看到的草台理论能很好的总结现在这拉垮的世界：\n文章的部分内容被密码保护：\nJavascript needs to be enabled to decrypt content 今年本来最重要的事是找到新工作，但拖延症加上年龄过大的不自信，一直只是想想，实际没投出去一份简历。。。\n感情生活上尝试和一个相亲对象保持了最长的联系记录，有8个月了，之前几个相亲对象都是吃完饭就断了联系。不过自己一直不想再进一步，还在犹豫是否要放弃。。。近排学到一个词是符合自己性格的：回避型依恋人格\n今年生活状态：\n未找到工作 未有女朋友，一直相亲中。。。 未会游泳 明年计划：\n找到工作 认真写一个业余产品 2021年年度选择如下：\n年度游戏： 糖豆人 今年没怎么玩游戏，休闲时就玩下糖豆人，但最近被epic收购后太恶心人了，期待明年的老头环\n年度动画： 灵笼 奇巧计程车 近几年国创的确崛起了，灵笼的战斗和剧情都很出色，终章白老板出场直接把期望值拉满了，期待明年的三体。奇巧计程车卡通的画风，但却有着非常吸引人的悬疑故事情节，今年最好看的日本动画。\n年度音乐： 爱你 - 王贰浪 打开 - 黄霄雲 秋天前 - 硬糖少女303 只记录下今年喜欢听的，没特别喜欢单曲循环的\n年度电影（电视剧）： 扎克·施奈德版正义联盟 沙丘 山海情（前半部） 年度图书： 无\n年度APP： 无\n移动互联网十年黄金发展期已过，开始进入存量博弈阶段，很难再出现有趣的app了\n年度网站： 无\n年度数码： AppleTV 小米净水器q600 AppleTV是看到有开源的第三方b站app才买的，电视内置的android系统太慢了，现在已配置满足自己所有影音需求，赞😄。小米q600净水器有我一直期望的功能：自加热，没陈水，虽然还不太完美，用到现在很满意。\n","date":"2021-12-28T15:03:08+08:00","image":"https://blog.xenori.com/2021/12/the-summary-of-2021/cover_hu09e89b295a2142cea2852e4ea002a726_132088_120x120_fill_q75_box_smart1.jpeg","permalink":"https://blog.xenori.com/2021/12/the-summary-of-2021/","title":"2021年度总结"},{"content":"本文主要是探讨下b站的音视频流分离dash格式实时转为hls流媒体，以方便在旧的播放器上播放。\n什么是DASH dash是基于HTTP的动态自适应流（英語：Dynamic Adaptive Streaming over HTTP，也称MPEG-DASH）的简称。现在b站最新的视频都是返回这种格式，并且是音视频分离的。b站dash实践可以参考这篇ppt: MPEG-DASH在bilibili的应用与实践\n转换HLS的实现方式 b站dash音视频分别为单独的两个链接，不同的码率和编码对应不同的链接，下面只是使用其中一个音视频链接来举例。实现方式如下：\n提供生成m3u8文件的http服务，m3u8视频块根据时长(duration)切分为5秒为一片，m3u8格式如下： #EXTM3U #EXT-X-VERSION:3 #EXT-X-MEDIA-SEQUENCE:0 #EXT-X-ALLOW-CACHE:YES #EXT-X-TARGETDURATION:5 #EXT-X-PLAYLIST-TYPE:VOD #EXTINF: 5.000000, http://xxx/api/hls/segments/1 #EXTINF: 5.000000, http://xxx/api/hls/segments/2 .... 拿不到总的时长的话，可以通过ffprobe命令获取： ffprobe -v quiet -print_format json -show_format \u0026#34;http://xxx/video.m4s\u0026#34; http服务的响应头content-type需设为application/vnd.apple.mpegurl 提供切片下载的http服务，如上面m3u8文件中的http://xxx/api/hls/segments/1，切片可以通过ffmpeg进行音视合并和切分，命令如下： # 切分从视频第(-ss)5.00秒开始，时长(-t)5.00秒 # -ss和-initial_offset数值需要根据当前切片递增 ffmpeg -timelimit 45 -ss 5.00 -i http://xxx/video.m4s -ss 5.00 -i http://xxx/audio.m4s -t 5.00 -c:v libx264 -preset veryfast -c:a copy -force_key_frames \u0026#34;expr:gte(t,n_forced*5.000)\u0026#34; -f ssegment -segment_time 5.00 -initial_offset 5.00 pipe:out%03d.ts # 同时合并字幕xxx.srt ffmpeg -timelimit 45 -ss 5.00 -copyts -i http://xxx/video.m4s -ss 5.00 -i http://xxx/audio.m4s -t 5.00 -vf subtitles=xxx.srt -c:v libx264 -preset veryfast -c:a copy -force_key_frames \u0026#34;expr:gte(t,n_forced*5.000)\u0026#34; -f ssegment -segment_time 5.00 -initial_offset 5.00 -ss 5.00 pipe:out%03d.ts 本命令是把重新编码后的视频数据输出到控制台，需要http服务把输出数据实时写入到响应中，这样播放器就能实时下载播放了 会遇到的问题 ffmpeg切片时音频使用了copy命令，但视频却使用libx264重新编码，导致转码很慢，而且cpu占用居高不下，为什么视频不也用copy模式，避免重新转码？\n这是因为ffmpeg视频copy模式切片时只能根据关键帧切分，这样会导致每个切片可能会多几帧，播放时出现画面重复播放和声画不同步，具体问题可参考：https://www.jianshu.com/p/f7d83fdec111\n切片重新编码是避免不了了，如何可以提高转码速度，降低cpu占用？\n——视频编码硬件加速！\nffmpeg硬件加速 视频编码硬件加速主要有如下几种：\nVAAPI：intel集显支持，是openwrt中最常见和使用的 QSV：intel集显支持，可在intel产品规格页搜索自己的cpu，看下有没支持Quick Sync Video NVENC：nvidia显卡支持，openwrt中一般没独立显卡，很少使用到 这里只介绍最常用的vaapi方式，ffmpeg编码时使用vaapi硬件加速切片命令如下：\n# 开启vaapi硬件加速编码 ffmpeg -vaapi_device /dev/dri/renderD128 -timelimit 45 -ss 5.00 -i http://xxx/video.m4s -ss 5.00 -i http://xxx/audio.m4s -t 5.00 -vf \u0026#39;format=nv12,hwupload\u0026#39; -c:v h264_vaapi -c:a copy -force_key_frames \u0026#34;expr:gte(t,n_forced*5.000)\u0026#34; -f ssegment -segment_time 5.00 -initial_offset 5.00 pipe:out%03d.ts # 同时合并字幕xxx.srt ffmpeg -vaapi_device /dev/dri/renderD128 -timelimit 45 -ss 5.00 -copyts -i http://xxx/video.m4s -ss 5.00 -i http://xxx/audio.m4s -t 5.00 -vf \u0026#39;subtitles=xxx.srt,format=nv12,hwupload\u0026#39; -c:v h264_vaapi -c:a copy -force_key_frames \u0026#34;expr:gte(t,n_forced*5.000)\u0026#34; -f ssegment -segment_time 5.00 -initial_offset 5.00 -ss 5.00 pipe:out%03d.ts -vaapi_device /dev/dri/renderD128，-vf 'format=nv12,hwupload'和-c:v h264_vaapi这三个参数是必须的\n如何在docker中使用硬件加速 假如hls流服务是部署在docker中使用的，打开硬件加速可以使用已经安装了vaapi支持的镜像。jrottenberg/ffmpeg有生成好的支持vaapi的docker镜像，镜像名称带有vaapi标签，可自行搜索需要的ffmpeg版本使用\ndocker启动时，需要使用--device参数绑定显卡设备：\ndocker run --device /dev/dri:/dev/dri jrottenberg/ffmpeg:vaapi 在openwrt中使用的话中，可在docker配置页device栏绑定显卡设备\n参考资料 FFMPEG参数说明：https://ffmpeg.org/ffmpeg-all.html#Format-Options DASH协议直播应用：https://cloud.tencent.com/developer/article/1895146 ","date":"2021-11-22T14:40:11+08:00","image":"https://blog.xenori.com/2021/11/dash-to-hls/cover_hu37be5b37634337e5cedb4c33df70e78c_168773_120x120_fill_q75_box_smart1.jpeg","permalink":"https://blog.xenori.com/2021/11/dash-to-hls/","title":"dash实时转换hls流媒体播放"},{"content":"本文的方案只针对局域网内使用bitwarden的情况。实现原理是使用ACME DNS验证方式验证域名所有权。\n手机app连接自建bitwarden服务时，需要接口必须是https的，经过比较，决定使用cloudflare代理来实现，这样不用考虑https证书的更新问题。\n创建bitwarden域DNS记录 在Cloudflare的DNS面板中创建一条bitwarden服务域的DNS记录，并关闭代理功能，ipv4地址填写openwrt路由地址：\n创建 API 令牌 在Cloudflare的概述面板中，点击右下角的获取您的 API 令牌，进入创建令牌页。点击创建令牌，并选择使用模板编辑区域DNS：\n按照下面图片所示创建访问权限，区域资源中可限定为刚刚的DNS域，也可指定为帐号下的所有域：\n一直点击下一步直到完成，复制出api token，并保存好，下面步骤会用到。\n下载安装caddy 进入caddy下载页，下载对应版本，需要选上caddy-dns/cloudflare模块。caddy如何安装，可以参考我之前的文章——openwrt管理后台使用caddy代替uhttpd\n配置caddy 打开caddy配置文件，增加下面的配置：\nbwrs.xxx.com { tls { dns cloudflare \u0026lt;my_api_token\u0026gt; } reverse_proxy localhost:8143 } bwrs.xxx.com请改为cloudflare的注册域，\u0026lt;my_api_token\u0026gt;替换为刚申请的api令牌，反向代理端口8143是bitwarden的服务端口，请按自己的情况替换。\n修改后，重启caddy使配置生效。\nopenwrt添加本地DNS解释记录 进入openwrt后台，点击网络 -\u0026gt; DHCP/DNS，在自定义挟持域名栏添加以下DNS记录：\n地址请填写openwrt路由地址，到这里就全部配置完成了。\n测试是否生效 通过curl请求bitwarden服务看有没内容返回\ncurl https://bwrs.xxx.com ","date":"2021-10-20T22:16:11+08:00","image":"https://blog.xenori.com/2021/10/bitwarden-tls-with-cloudflare/cover_huf0b9d0d93b3d44f22f6efd294836ba7f_10731_120x120_fill_box_smart1_3.png","permalink":"https://blog.xenori.com/2021/10/bitwarden-tls-with-cloudflare/","title":"自建Bitwarden通过cloudflare实现https访问"},{"content":"openwrt管理后台默认是使用uhttpd提供服务的。一段时间体验下来发现uhttpd有时会没响应，查不到具体原因，只能重启才会恢复正常。为了稳定性和强大的反向代理功能，决定在软路由上使用caddy代替uhttpd。\n暂停uhttpd服务 uhttpd服务占用了80端口，需要先暂停。使用ssh登录openwrt，执行下面命令暂停uhttpd服务：\n/etc/init.d/uhttpd stop /etc/init.d/uhttpd disable 下载caddy 访问caddy官网下载最新版本的caddy，intel cpu需要下载Linux amd64版本，额外功能模块选上aksdb/caddy-cgi/v2。 下载后放到/usr/bin目录下，并重命名为caddy，并给予执行权限：\nwget \u0026#34;https://caddyserver.com/api/download\\?os\\=linux\\\u0026amp;arch\\=amd64\\\u0026amp;p\\=github.com%2Faksdb%2Fcaddy-cgi%2Fv2\\\u0026amp;idempotency\\=32032912354333\u0026#34; -o /usr/bin/caddy chmod +x /usr/bin/caddy 配置caddy 增加下面的配置，并放到/etc/caddy/Caddyfile文件中：\n{ order cgi before respond } :80 { @notcgi { not path /cgi-bin/* not path / } redir / /cgi-bin/luci file_server @notcgi { root /www } cgi /cgi-bin/luci* /www/cgi-bin/luci { script_name /cgi-bin/luci # 下面这句很重要，要不然部分服务控制台会工作不正常 unbuffered_output } } 增加启动脚本 增加自启动脚本，并保存到/etc/init.d/caddy中：\n#!/bin/sh /etc/rc.common START=99 SERVICE_USE_PID=1 SERVICE_WRITE_PID=1 SERVICE_DAEMONIZE=1 start() { service_start /usr/bin/caddy run --config /etc/caddy/Caddyfile } stop() { service_stop /usr/bin/caddy } 给予执行权限：\nchmod +x /etc/init.d/caddy 运行 执行下面脚本运行caddy服务，并加入到自启动中：\n/etc/init.d/caddy enable /etc/init.d/caddy start 成功启动后，就可以正常访问后台了：）\n","date":"2021-08-11T07:58:11+08:00","image":"https://blog.xenori.com/2021/08/openwrt-caddy-replace-uhttpd/cover_hufe207fe89d0287cb3e5f620d05c77655_45456_120x120_fill_q75_box_smart1.jpeg","permalink":"https://blog.xenori.com/2021/08/openwrt-caddy-replace-uhttpd/","title":"openwrt管理后台使用caddy代替uhttpd"},{"content":"Mac下的PopClip是我很喜欢的应用，一直想在Windows下找个替代的，但一直没找到，就准备自己简单实现一个。但研究后发现，Windows下是没有统一的API接口来获取当前用户选中文字的。商业化的GetWord组件可以实现，效果不错，但是这组件是不能免费在非商业应用中使用的。\n经过一番网络查找后，发现有几个方案可以获取到，但都有优缺点，都不完美，需要把几种方案结合起来使用才能获取大部分情景下的选中文字。下面记录下这几种不同的实现方案：\nMicrosoft UI Automation Microsoft UI Automation是UI的自动化测试框架，提供对windows用户界面（UI）相关信息的编程访问。它提供的IUIAutomationTextPattern接口，可以用来获取文本控件的选中内容，获取示例（C#）：\nvar el = AutomationElement.FocusedElement; object pattern; if (el.TryGetCurrentPattern(TextPattern.Pattern, out pattern)) { var selectRanges = ((TextPattern)pattern).GetSelection(); foreach (var rng in selectRanges) { Console.WriteLine(rng.GetText(-1)); } } 优点：官方支持的接口，edge、chrome等浏览器内容都能获取到\n缺点：很多应用不支持这接口，或支持得不好，测试发现有些使用.Net组件能获取的，但自己用Go+Win32就没法正确获取\nEM_GETSEL \u0026amp; WM_GETTEXT message 向windows窗口发送EM_GETSEL消息，可以获取到编辑控件当前选中文本的起始和结束索引位置，结合WM_GETTEXT获取编辑控件当前文本内容，就能计算出选中的文字，获取示例（Go）：\nfunc getSelection() (string, error) { // attach to other windows thread var processId uint32 var attach = false forgroundWnd := win.GetForegroundWindow() targetThreadId := GetWindowThreadProcessId(forgroundWnd, \u0026amp;processId) currentThreadId := GetCurrentThreadId() if targetThreadId != currentThreadId { attach := AttachThreadInput(currentThreadId, targetThreadId, true) if attach == 0 { return \u0026#34;\u0026#34;, fmt.Errorf(\u0026#34;AttachThreadInput failed\u0026#34;) } } focusWnd := win.GetFocus() //Get total text length textlength := uint32(win.SendMessage(focusWnd, win.WM_GETTEXTLENGTH, 0, 0)) //Have any text at all? if textlength \u0026gt; 0 { textlength = textlength + 1 //Get selection selstart := 0 selend := 0 win.SendMessage(focusWnd, win.EM_GETSEL, uintptr(unsafe.Pointer(\u0026amp;selstart)), uintptr(unsafe.Pointer(\u0026amp;selend))) sb := make([]uint16, textlength) win.SendMessage(focusWnd, win.WM_GETTEXT, uintptr(textlength), uintptr(unsafe.Pointer(\u0026amp;sb[0]))) //Slice out selection value := syscall.UTF16ToString(sb) length := len(value) if (length \u0026gt; 0) \u0026amp;\u0026amp; (selend-selstart \u0026gt; 0) \u0026amp;\u0026amp; (selstart \u0026lt; length) \u0026amp;\u0026amp; (selend \u0026lt;= length) { if attach { AttachThreadInput(currentThreadId, targetThreadId, false) } return value[selstart:selend], nil } } if attach { AttachThreadInput(currentThreadId, targetThreadId, false) } //Failed :( return \u0026#34;\u0026#34;, fmt.Errorf(\u0026#34;get selected failed\u0026#34;) } 优点：支持旧的winform、win32应用\n缺点：新的WPF、UWP应用不支持\nHook TextOut API 部分windows应用或游戏是通过底层GDI++的TextOutW或ExtTextOutW接口渲染文字的，我们可以通过HOOK技术，把这些接口替换为我们自己的接口，调用InvalidateRect让应用重绘下鼠标划过的区域，这样应用再调用ExTextOutW接口渲染时，就能拿到相应的文字了。具体原理可以参考这篇论文：Principle of Capturing Word from Screen and Its Implement Methods，相关示例项目可参考：\nTextractor Prochook64 优点：支持获取旧游戏的文本\n缺点：实现难度大，现在大多数应用都是通过TrueType字体文件渲染的，只能拿到GLYPH_INDEX，拿不到最原始的文字。\nOCR 截图鼠标划过的区域，再通过OCR出来文字，很多词典软件的鼠标取词通过这方式实现\n优点：任何windows应用都支持\n缺点：OCR处理慢，混合多语言文字准确度不高\nClipboard 通过模拟复制命令，把选中文字先复制到剪贴板，再从剪贴板取出来。使用示例（Go）：\nfunc getSelectionByClipboard() (string, error) { hwnd := win.GetForegroundWindow() winText := make([]uint16, 1000) GetWindowText(hwnd, \u0026amp;winText[0], uint32(len(winText)-1)) windowName := syscall.UTF16ToString(winText) // save old clipboard content oldClipboardText, _ := GetClipboardText() // current sequentNumber oldSeqNumber, _ := GetClipboardSequenceNumber() // send ctrl+c copy event if strings.Contains(windowName, \u0026#34;Internet Explore\u0026#34;) || strings.Contains(windowName, \u0026#34;Microsoft Edge\u0026#34;) { // Internet Explore ignore ctrl+c click event win.PostMessage(hwnd, win.WM_COMMAND, 0x0001000f, 0) } else { // send selected to clipboard SendCopy() } clipboardChange := \u0026lt;-waitForClipboardChange(oldSeqNumber) if clipboardChange { text, _ := GetClipboardText() // restore old clipborad state UpdateClipboardText(oldClipboardText) return text, nil } //Failed :( return \u0026#34;\u0026#34;, fmt.Errorf(\u0026#34;get selected failed\u0026#34;) } func waitForClipboardChange(oldSeqNumber uint32) chan bool { waitChangeCh := make(chan bool) timeout := 200 runTime := 0 changeCheckTimer := time.NewTimer(10 * time.Microsecond) go func() { for { \u0026lt;-changeCheckTimer.C seqNumber, _ := GetClipboardSequenceNumber() if seqNumber != oldSeqNumber { waitChangeCh \u0026lt;- true return } runTime += 10 if runTime \u0026gt; timeout { waitChangeCh \u0026lt;- false return } changeCheckTimer.Reset(10 * time.Microsecond) } }() return waitChangeCh } 优点：支持复制的应用都可以支持，如excel，word等\n缺点：污染系统剪贴板，当用户有使用剪贴板历史软件时，会看到所有选中的文字\n","date":"2021-05-13T15:43:11+08:00","image":"https://blog.xenori.com/2021/05/get-selected-text-in-windows/cover_hu90631fcbde72e8234611f36d2c8c7c3a_13255_120x120_fill_box_smart1_3.png","permalink":"https://blog.xenori.com/2021/05/get-selected-text-in-windows/","title":"Windows下获取鼠标当前选中文字"},{"content":"近排折腾 jellyfin 的 DLNA 服务时，发现 DLNA 有很多限制：不支持外挂字幕，DTS 音频的视频文件没法播放声音等。下面介绍几种 mkv 视频文件的修改方法，以满足 DLNA 的播放需求。\nmkv 增加中文字幕 相关软件：mkvtoolnix\n下载地址：https://pan.baidu.com/s/1J-vXqkArWMSmB3wfDBi-Yg 提取码: vamn\n大家可以到官网下载最新版，下载后，找到mkvtoolnix-gui.exe打开，把 mkv 拖进界面，就可以看到 mkv 封装的文件内容了： 点击最下面的添加输入文件，选择src格式的字幕文件，确认后就可以看到新字幕已添加到文件列表最下方了 用鼠标可以拖动字幕文件的顺序，假如你想新字幕默认显示，可以把新加的字幕拖到所有字幕的最上面，并在右边属性框中，把默认轨道标记设为是，这样每次打开视频，就会默认显示新加的字幕了 点击最下面的开始混流按钮，等进度条跑到 100%，就合成输出新的 mkv 文件了：） mkv 的 dts 音频转换为 ac3 相关软件：PopCorn MKV AudioConverter\n下载地址：https://pan.baidu.com/s/1jYv8Y6M49iszq8d30p62ag 提取码: trg6\n打开软件，点击File specification中的Browser，打开需转换 DTS 的 mkv 视频文件，打开后在下方会显示相关视频信息。 在右边的DTS属性框，选择Convert to Dolby Digital，Bitrate 一般选择448就可以了，Cleanup DTS track before re-encode选择Always，这样会把原有的 DTS 音轨删除，避免影响 DLNA 服务播放。 点击File specification中的Run按钮，就会开始编码生成新的 mkv 文件了：） ","date":"2021-02-28T15:43:11+08:00","image":"https://blog.xenori.com/2021/02/mkv-edit/cover_hu6f976395ac37733425246464b267ef40_38942_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.xenori.com/2021/02/mkv-edit/","title":"mkv修改加字幕-dts音频转ac3"},{"content":"创建分支 根据 commit 创建新分支 git checkout -b branch_name commit_id_xxx 回滚 还原本地修改过的文件 # 会还原本地所有修改过的文件！！ git checkout . # 删除新增未监视的文件(untracked files) git clean -fd 丢弃本地上一次提交 # 回退到上一个 commit 版本 git reset HEAD^ 回滚到指定版本 # 还原到指定的旧版本 git reset --hard \u0026lt;old_commit_id\u0026gt; # 还原到上一版本 git reset HEAD^ # 新修改处理... # 强制push更新覆盖远程仓库 git push -f origin master 标签 tag 删除指定 tag # 先删除远程tag git push origin :refs/tags/v0.x.x # 再删除本地tag git tag -d v0.x.x 删除匹配的部分 tag # 先删除远程tag，支持*模糊匹配 git push -d origin $(git tag -l \u0026#34;v0.1*\u0026#34;) # 再删除本地tag git tag -d $(git tag -l \u0026#34;v0.1*\u0026#34;) 删除所有 tags # 先删除所有远程tag git tag -l | xargs -n 1 git push --delete origin # 再删除所有本地tag git tag | xargs git tag -d Commit 修改 清空所有历史 commit # 创建新的master分支 git checkout --orphan new_master git add -A git commit -am \u0026#34;First commit\u0026#34; # 删除旧master分支 git branch -D master # 新master分支改名为master git branch -m master # 强制push更新覆盖远程仓库 git push -f origin master 合并多个 commit # 切换回master分支，并获取最新代码 git checkout master git pull # 把分支的多个提交合并为一个 git merge --squash feature-branch-xxxx git commit -m \u0026#34;merge commit message\u0026#34; git push 多帐号 提交时提示输入帐号 git config --local credential.helper \u0026#34;\u0026#34; # git地址要使用http协议 git remote set-url origin https://xxx.com/xxx.git ","date":"2021-02-22T16:58:10+08:00","image":"https://blog.xenori.com/2021/02/git-commands/cover_hu32dfdc231ed91eb0b8531abf7aa78221_50815_120x120_fill_box_smart1_3.png","permalink":"https://blog.xenori.com/2021/02/git-commands/","title":"常用git命令"},{"content":"今年对大部分人来说，都会是难忘和难过的一年。年初新冠肺炎大爆发，到处寸步难行，食肆工厂关闭。年中中美关系加剧恶化，中印边境紧张，让人对未来几年的形势越来越担忧，年末新冠肺炎再次来袭，希望不会再出现大爆发了。\n文章的部分内容被密码保护：\nJavascript needs to be enabled to decrypt content 生活上还是变化不大，时间越来越快了。今年活得比较颓废，现在年龄太大，工作不好找，在转行和找工作间\b不断徘徊。比较熟的朋友都结婚生子了，平时也不好联系他们，对未来找不到方向。\n今年生活状态：\n学完车，拿到C1驾照 未有女朋友，未婚 未会游泳 2020年年度选择如下：\n年度游戏： 2077赛博朋克 绝地求生（手机） 为了玩 2077，下半年配了新电脑，的确算好玩的，推荐玩 PC 版。只是 BUG 比较多，主机版被批得不成人形了\n年度动画： 我的三体之章比海传 没想到唯一的是国创😂，虽然画风精奇，但有三体剧本底子在，再加上不错的宏大画面表现和音乐，是难得的佳作。日本动画越来越\b低幼卖萌向，看不到出路，唯一期待的进击的巨人最终季刚出，要算到 2021 年了。\n年度音乐： 推开世界的门 - 杨乃文 荒蛋 - 太一 世界不会轻易崩塌 - 打扰一下乐团 今年的歌只能择优记录下，没有特别非常喜欢的，不过今年因为喜欢看综艺的原因，认识了两个新生代不错的歌手：太一、华晨宇，感觉都很有才华，创作力也强，歌词有点非常人思维😂，感觉中国流行音乐开始有些起色了。\n年度电影（电视剧）： 沉默的真相 真相捕捉 唐人街探案 今年因疫情原因，没什么电影上映，今年都是看电视剧。《沉默的真相》和《唐人街探案》使我对国产剧大大改观了，非常好看，强烈推荐。《唐人街探案》记得只需要看前 8 集，最后 4 集是送的广告😂\n年度图书： 没看书。。。\n年度APP： bilibili 雪球 日常使用，bilibili 今年股价翻了几翻了，本来刚上市时想买的，但美股开户汇金太复杂了没搞\n年度网站： 无\n年度数码： Oculus Quest 2 Nvidia 3070 第一次接触 VR，很新奇，就是近视原因佩戴不方便。\n","date":"2021-01-15T16:03:08+08:00","image":"https://blog.xenori.com/2021/01/the-summary-of-2020/cover_hu3cc7554004a4f82bf46186159a47e918_367117_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.xenori.com/2021/01/the-summary-of-2020/","title":"2020年度总结"},{"content":"WOL网络唤醒是用来实现通过特定的指令唤醒同一局域网下已关机 PC 的功能。现在常用的 DLNA 和 moonlight 软件都支持 WOL 功能，这篇文章只要记录下华硕主板如何打开 WOL 功能（其他厂商的主板大同小异，只要是 BIOS 选项和网卡选项会有些差别）。实现 WOL 功能的 PC 主机是必须通过网线连接在同一局域网下的，只有 WIFI 连接没法实现。\n1、主板 BIOS 中打开 WOL 功能 进入主板BIOS，把如下配置项设为enabled（不同的主板 BIOS 可能会有出入，请以说明书为准）：\nAdvanced -\u0026gt; APM Configuration -\u0026gt; Power On By PCI-E/PCI -\u0026gt; Enabled Restore AC Power Loss最好也设置为Last State，这样可以保证断电恢复后，也能保持唤醒。\n保存后重启进入 windows\n2、配置 windows 10 网卡属性 假如网络设置中找不到以上选项，可以尝试下载安装最新的网卡驱动，windows默认的网卡驱动有时会缺少以上选项的。\n点击 windows 任务栏右下角网络连接图标，选择网络和Internet设置：\n选择高级网络设置 -\u0026gt; 更改适配器选项：\n右键以太网链接，选择属性，再点击配置：\n点击属性的电源管理，把图片中的如下三项都勾选上：\n再点击高级，确保唤醒模式匹配和唤醒魔包都是启用状态：\n\b在高级选项卡中，看下是否存在启用 PME，有的话，也需要启用，启用这项是为了避免关机后主板切断网口的电源，导致没法唤醒 3、关闭 windows 10 快速启动 在打开快速启动电源选项时，windows默认关机功能是进入S4状态，这种状态是不能WOL唤醒的，需要在控制面板 -\u0026gt; 电源选项 -\u0026gt; 选择电源按钮的功能中，关闭快速启动。\n4、测试 WOL 关机后，假如有线网口连接灯一直闪烁，就证明 WOL 已经配置成功了，可通过如下软件测试是否成功。\nMAC：\nbrew install wakeonlan wakeonlan XX:XX:XX:00:4C:00 Android：\n下载Wake On Lan app\nIPhone：\n下载mocha-wol app\n5、如何实现远程关闭 PC 可以通过安装Remote Shutdown Manager实现，详细请参考：\nhttps://github.com/karpach/remote-shutdown-pc 结合homeassistant还能实现语音控制 PC 开关😄\n参考资料 WOL 网络唤醒避坑指南：常见问题的分析与内容补充 ","date":"2020-12-22T13:27:10+08:00","image":"https://blog.xenori.com/2020/12/intel-ax200-wol/cover_hub30f7ee69edd8057ef89d1f53b8e0faa_9040_120x120_fill_box_smart1_3.png","permalink":"https://blog.xenori.com/2020/12/intel-ax200-wol/","title":"华硕主板AX200网卡如何开启WOL网络唤醒"},{"content":" 19年时为了开发时字体显示能有更好的效果，所以准备入手一台 4K 的显示器。经过一系列的筛查比较后，最后买了苹果官网的 LG UltraFine 4k 显示器，选它的原因只要有两点：\n带 type-c 的雷电3接口，方便笔记本 Macbook Pro 可以直连输出 24 寸的 4K 分辨率，Windows 连接时，开 200% 文字缩放时效果和大小刚刚最好 之前也想过买 DELL 的 type-c 显示器，但看到只有 27 寸，纠结了一段时间后最后还是放弃了😓\n苹果官网销售过 4 种型号的 LG UltraFine 显示器，下面推荐的连接设备只适合最新的 LG UltraFine 24 寸 4K显示器，最新的 5K 正常也可以连接，但最多获得 4k 60HZ 的显示效果，没法 5K 显示。\n22MD4KA (21寸4K带摄像头，不支持)： 27MD5KA (5k，不支持) 24MD4KL (24寸4k无摄像头，支持) 27MD5KL (5k，部分支持) 不使用雷电3输出到 LG UltraFine，需要 windows 设备的图像输出支持Display Alt Mode技术，有一些 Windows 笔记本有全功能 type-c 接口，但因为不支持Display Alt Mode，导致直连 UltraFine 也是没法激活显示的。现在已知支持Display Alt Mode的 type-c 接口，就只有 Nvidia 20系列显卡自带的 VirtrualLink 接口了，可以直连 UltraFine 显示器，但最新的 30 系列显卡因为近年 VR 不流行又砍掉这个接口了😂\n下面介绍的设备都是通过把 DP 信号和 USB 信号转换为支持Display Alt Mode信号实现的。\n华为 VR 计算机连接线 这线现在已绝版，只能在闲鱼上淘，但因为货少价格都比较贵，我刚开始关注时在淘宝上是 188 左右的价格。。。\n贝尔金（BELKIN）计算机数据线 京东和华为官网有现货， 4.5 米长，4xx 左右的价格\nWacom Link Plus 多媒体适配器ACK42819（推荐） 京东上有现货，比较贵，5xx 左右的价格，闲鱼可以淘到便宜些的，300 元左右。这个的好处是比较小，可以直接贴在 UltraFine 显示器后面，相当于用一个雷电3口换一个 DP 输入（连接这设备 type-c 口要使用全功能 type-c 线，而不是雷电 3 线）\n另外，假如你想买支持雷电 3的主板直连 UltraFine 的话，记得确认下主板是否带DP IN的接口，像华擎（ASRock）X570 Phantom Gaming这种的。因为只有带了DP IN接口，才能把独立显卡的信号转接到主板雷电3接口，以便输出图像到 UltraFine，要不然主板的雷电3就只能支持cpu的核显输出的，不支持独立显卡。\n戴尔(DELL) UPD2018 带 type-c 的 PCI-E 转接卡，可适用于 AMD 主板。\n使用华为 VR 线或 Wacom 适配器方式连接，有时 UltraFine 显示器断电后再打开，首次开机没法点亮屏幕，需要重新\b插拔一次显示器 type-c 线才可以，具体原因不明。网上给出的解决方案是先打开电脑，等电脑进入 windows 后，再打开显示器电源\n相关资料：\nhttps://forums.macrumors.com/threads/lg-ultrafine-4k-and-5k-yes-you-can-connect-it-to-windows-computers-via-dp.2227756/ ","date":"2020-09-11T13:07:10+08:00","image":"https://blog.xenori.com/2020/09/connect-ultrafine-with-windows/cover_hu99a744ea0805facb74e8940a81aa0415_252308_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.xenori.com/2020/09/connect-ultrafine-with-windows/","title":"Windows下如何连接LG UltraFine 4k显示器"},{"content":"1. 查看连接设备 adb devcies 2. 当有多个连接设备时，指定执行命令的设备 adb -s \u0026lt;deviceid\u0026gt; \u0026lt;commands\u0026gt; 如 adb -s 1e25fe71 shell pm list package 3. 查看手机中已安装的所有apk文件 adb shell pm list package 4. 导出指定的 apk 包 adb shell pm path \u0026lt;com.package.name\u0026gt; adb pull \u0026lt;/system/priv-app/com.package.name/package_name.apk\u0026gt; ~/download/savepath 5. 卸载任意（包括系统）应用 adb shell pm uninstall -k --user 0 \u0026lt;com.package.name\u0026gt; 6. 查看 app 的错误日志 adb logcat -v time | grep AndroidRuntime 7. 清空 app 日志 adb logcat -c ","date":"2020-09-11T11:27:10+08:00","image":"https://blog.xenori.com/2020/09/adb-commands/cover_hue20e1dd7e1cc2b633286b68d411b60b1_20902_120x120_fill_box_smart1_3.png","permalink":"https://blog.xenori.com/2020/09/adb-commands/","title":"常用adb命令"},{"content":"在 android 9 以上版本，很多 app 都使用certificate pinning技术来防止 https 中间人攻击，当 app 检测到证书不正确时，会自动断开网络请求，导致抓取不到 https 网络请求包。\n要顺利抓到 https 请求包，需要借助VMOS来避开certificate pinning检测。\n1、安装VMOS 在网盘中下载VMOS，安装完后，打开VMOS，点击右上方的+按钮添加虚拟机，选择最下方的安卓7.1极客版，下载并安装完成。 回到首页，点击启动虚拟机，进入虚拟机 点击下方的常用工具-\u0026gt;应用，找到需抓包的软件，点击后导入安装 VMOS下载地址：https://pan.baidu.com/s/1UBNon-dT37G3NuFMcO_szw 提取码: wis3\n2、安装抓包软件httpcanary 自行下载安装：\n蓝奏：https://www.lanzous.com/i6hw4ti\n百度：https://pan.baidu.com/s/11fx67kcqQOwxCLdItAXIxA 提取码: ccbd\n3、抓取 app 的 https 请求 先运行httpcanary，再在VMOS中访问需抓包的 app，就能看到所有 https 请求了，在VMOS中运行的 app，是不会检测certificate pinning的\n","date":"2020-07-01T11:27:10+08:00","image":"https://blog.xenori.com/2020/07/how-capture-https-network-packet/cover_hu7ad816a800b39ebbf98b64bf468ff9ae_63683_120x120_fill_box_smart1_3.png","permalink":"https://blog.xenori.com/2020/07/how-capture-https-network-packet/","title":"[更新]使用httpcanary在android 9以上版本抓取https网络请求包"},{"content":"阿里云统一官方镜像站：https://developer.aliyun.com/mirror/ 包含了所有开源的国内镜像源，如homebrew，npm，pip，centos等，差不多满足所有开发需求， 🐂🍻 go get 国内源 七牛：https://goproxy.cn\n官方全球加速CDN：https://goproxy.io/\n第三方：https://gocenter.io\npip 国内源 清华：https://pypi.tuna.tsinghua.edu.cn/simple\n阿里云：http://mirrors.aliyun.com/pypi/simple/\n中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/\n华中理工大学：http://pypi.hustunique.com/\n山东理工大学：http://pypi.sdutlinux.org/\n豆瓣：http://pypi.douban.com/simple/\n使用方法 临时使用：\npip install pyspider -i https://pypi.tuna.tsinghua.edu.cn/simple 永久修改，一劳永逸：\nLinux下，修改 ~/.pip/pip.conf (没有就创建一个文件夹及文件。文件夹要加“.”，表示是隐藏文件夹)\n内容如下：\n[global] index-url = https://pypi.tuna.tsinghua.edu.cn/simple [install] trusted-host=mirrors.aliyun.com gradle国内源 阿里：http://maven.aliyun.com/nexus/content/groups/public\n使用方法 配置只在当前项目生效： 在 build.gradle 文件内修改/添加 repositories 配置\nrepositories { maven { url \u0026#34;http://maven.aliyun.com/nexus/content/groups/public\u0026#34; } } 配置全局生效： 找到 (用户家目录)/.gradle/init.gradle 文件，如果找不到 init.gradle 文件，自己新建一个修改/添加 init.gradle 文件内的 repositories 配置\nallprojects { repositories { maven { url \u0026#34;http://maven.aliyun.com/nexus/content/groups/public\u0026#34; } } } ","date":"2020-05-07T11:27:10+08:00","permalink":"https://blog.xenori.com/2020/05/china-speedup-source-for-develop/","title":"各种开发相关的国内源"},{"content":"入住万科小区后，每次出入都要经过两次门禁，导致虽然装了智能锁，但还是要带门禁卡，所以一直想着怎样把门禁复制到手机 NFC 上。一加7 pro 在 11 月已推送了门禁卡功能，但只支持未加密的门禁卡，万科的一卡通都是加密过的，所以直接复制不了。\n加密卡也分半加密或全加密，属于哪种类型，可以手机下载 MifareClassicTool (MCT) 查看，部分扇位可以看到内容的就是半加密，所有扇位内容都看不到的就是全加密卡，全加密卡的话，建议直接放弃，破解密钥需要太多时间了。\n经过在酷安浏览 NFC 相关内容，发现是有方法可以实现复制的，但需要一个 PN532 的 NFC 解密设备和 CUID 空白卡，复制流程如下：\n使用 PN532 解密半加密的原卡内容 把门禁卡的 0 扇区的 0 块的 UID 和厂商号写入 CUID 空白卡（这样空白卡就变成未加密卡了） 使用手机 NFC 模拟 CUID 空白卡 使用 PN532 或另一带 NFC 功能的手机把余下加密的所有扇区信息写下手机模拟的门禁卡 一、使用 PN532 解密半加密的原卡内容 pn532 如何连接电脑就不详述了，要解密原门禁卡密钥，需要下载windows 软件MifareOneTool，把门卡放到 PN532 上，然后选择高级模式 -\u0026gt; HardNested，软件就会开始执行爆力破解，在我 i6700K 电脑上，平均破解一个密钥需要 6 小时。。。一般进度到 30%～50% 就能破解到，只要还是看 RP😂\n扇区号填写需要破解密钥的扇区，1 个扇区有 A/B 两个密钥，所以一个扇区是需要破解两次的。\n破解 10 扇区的 A 密钥：\n破解 10 扇区的 B 密钥：\n破解原理可以看下面文章：一卡通(M1卡)破解过程记录——获取扇区密钥\n二、0 扇区 0 块写入 CUID 空白卡 写入 CUID 使用手机的 MifareClassicTool 。首先需要保存原门禁卡的已解密的 dump 文件。\n1.MCT 中选择编辑/增加密钥文件，在std.keys中增加刚才破解出来的密钥，一行一个\n2.手机靠近原门禁卡，使用读标签功能读取所有扇区的内容出来，并保存为转储文件。\n3.选择编辑/分析转储文件打开刚才保存的转储文件，复制 0 扇区 0 块的内容。\n4.手机靠近 CUID 空白卡，选择写标签功能，使用写块把刚刚复制的内容写入0扇区0块，如下图所示\n这样就得到了一个可以被手机 NFC 功能复制的未加密门禁卡\n三、使用手机 NFC 模拟 CUID 空白卡 正常都能模拟成功，但这里因为手机厂商的限制，有个坑，后面会说明\n四、把原卡加密内容写入手机模拟门禁 假如手上有另一台带 NFC 功能的手机，可以在另一手机也安装 MCT 直接写，手机选择刚刚模拟的门禁为默认卡就可以\nMCT 中选择写标签-\u0026gt;写转储(克隆)，选择之前保存的转储文件，勾上所有扇区并确认，这样就能把原卡所有内容完整复制到手机模拟的门禁了😆\n假如只有一台手机，可以在 windows 上通过 PN532 使用MifareOneTool写。不过 MCT 的转储文件在MifareOneTool中不能识别，需要先转为 MFD 文件，还好 MCT 的 github 库中提供了转换工具。\n访问https://github.com/ikarus23/MifareClassicTool/tree/master/tools/dump-file-converter下载mct2eml.py和eml2mfd.py工具，把 MCT 的转储文件（保存在手机/MifareClassicTool/dump-files/目录下）转换为 MFD 格式文件。\npython mct2eml.py path_to_mct_dump eml_dump.eml python eml2mfd.py path_to_eml_dump mfd_dump.mfd 手机选择模拟的门禁卡，靠近 PN532，在 MCT 中选择高级操作模式-\u0026gt;写M1，选中刚刚转换的 mfd_dump.mfd 文件，就能开始写入了\n五、拿模拟好的手机下楼刷卡 啲～一声，假如门开了，那么恭喜你，终于模拟成功了，假如门禁完全没反应，门开不了，那就是遇到上面第三点说的坑了——小区门禁校验了厂商号，而手机 NFC 限制不能覆写厂商号。\n现在主流厂商的手机模拟门禁功能都是限制了写厂商号，假如你小区的门禁是有校验厂商号的话，建议你放弃吧，这个没解了。。。曲线救国的方法就是改使用手机 NFC 卡贴或使用手机空白卡功能让物业登记给下权限\n相关参考资料：\nRFID安全之全加密Mifare Classic 1K卡破解 使用 PN532+PL2303HX 复制 JCOP41 校园卡 一卡通(M1卡)破解过程记录——获取扇区密钥 模拟加密NFC卡片方法 ","date":"2019-12-30T11:27:10+08:00","permalink":"https://blog.xenori.com/2019/12/use-pn532-copy-encryption-card-in-oneplus7pro/","title":"一加7 pro使用 pn532 复制手机加密门禁卡"},{"content":"使用最新的 node v12 安装 electron 时，发现每次跑到下面的语句就会挂住，无法继续安装：\n\u0026gt; electron@7.1.7 postinstall /Users/cxf/Dev/CapsIndicator/node_modules/electron \u0026gt; node install.js 查看网上相关解决方案，发现是因为 npm 需要连接 github 下载 electron 安装包导致，安装包有 60M 左右，但从 github 下载却只有几 KB，所以感觉是卡住了。但改使用淘宝的 cnpm 发现还是会卡住，这是因为 electron 的包默认还是指向 github 下载，还有 electron 提供了修改下载地址的环境变量electron_mirror，使用npm config设置配置变量\nnpm config set electron_mirror \u0026#34;https://npm.taobao.org/mirrors/electron/\u0026#34; 再次执行安装命令，虽然不会卡住了，但变为直接提示404安装失败：\n\u0026gt; electron@7.1.7 postinstall /Users/cxf/Dev/CapsIndicator/node_modules/electron \u0026gt; node install.js (node:2216) UnhandledPromiseRejectionWarning: HTTPError: Response code 404 (Not Found) at EventEmitter.\u0026lt;anonymous\u0026gt; (/Users/cxf/Dev/CapsIndicator/node_modules/got/source/as-stream.js:35:24) at EventEmitter.emit (events.js:210:5) at module.exports (/Users/cxf/Dev/CapsIndicator/node_modules/got/source/get-response.js:22:10) at ClientRequest.handleResponse (/Users/cxf/Dev/CapsIndicator/node_modules/got/source/request-as-event-emitter.js:155:5) at Object.onceWrapper (events.js:300:26) at ClientRequest.emit (events.js:215:7) at ClientRequest.origin.emit (/Users/cxf/Dev/CapsIndicator/node_modules/@szmarczak/http-timer/source/index.js:37:11) at HTTPParser.parserOnIncomingClient [as onIncoming] (_http_client.js:583:27) at HTTPParser.parserOnHeadersComplete (_http_common.js:115:17) at TLSSocket.socketOnData (_http_client.js:456:22) (node:2216) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). (rejection id: 1) (node:2216) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code. npm WARN capsindicator@1.0.0 license should be a valid SPDX license expression 查看 github issue#1050 后，发现是因为淘宝保存的版本目录和官方的不同，淘宝去掉了v前缀。\n// 官方 https://npm.taobao.org/mirrors/electron/v7.1.7/electron-v7.1.7-linux-x64.zip // 淘宝 https://npm.taobao.org/mirrors/electron/7.1.7/electron-v7.1.7-linux-x64.zip 好在 electron 官方也提供了修改目录名称的环境变量electron_custom_dir，配置改下：\nnpm config set electron_custom_dir \u0026#34;7.1.7\u0026#34; 再次运行安装命令，这次终于成功了😂\n官方相关的安装说明：\n","date":"2019-12-26T14:10:18+08:00","permalink":"https://blog.xenori.com/2019/12/fix-npm-hang-when-install-electron/","title":"解决npm 安装 electron 卡住，无法完成"},{"content":"Google — Year in Search 2019 豆瓣 - 2019 年度电影 豆瓣 - 2019 年度音乐 The Game Award 2019 新浪新闻年终盘点：#2019哪些瞬间值得被看见# ","date":"2019-12-25T12:18:12+08:00","permalink":"https://blog.xenori.com/2019/12/the-inventory-of-2019/","title":"2019 年回顾盘点"},{"content":"今年是暖冬，所以即使已过了冬至，广州的天气还只是秋瑟中带点凉意，1111 淘宝买的冬衣还没一次穿过出街==！\n文章的部分内容被密码保护：\nJavascript needs to be enabled to decrypt content 上周 3 刚被公司裁员，年末正式加入失业大军，现在只能游荡在图书馆，消磨下时间。现在年龄已奔四，对于继续从事开发工作，总是充满焦虑，再投简历找工作，感觉已很困难了。\n自从去年老爸中风后，到现在有一年时间了，腿还是麻痹无力状态，还是没法自己走路。平时都需要老妈看着，的确太辛苦了。每当这时间就会感觉身体健康是多么重要。\n今年生活状态：\n新房入伙，入住新房 未有女朋友，未婚 未学车 未会游泳 2019年年度选择如下：\n年度游戏： 只狼 绝地求生（手机） 只狼是今年游玩体验都好的，虽然最终 BOSS 还未通关，死的次数太多了。。。\n手机上的绝地求生不需要压枪，适合我这种轻度玩家，现在有时间都是玩它了，吃了几次鸡\n年度动画： 进击巨人 第3季 JOJO 第4季 年度音乐： 光年之外 来自天堂的魔鬼 今年因为听光年之外，喜欢上了听邓紫棋的歌，特别喜欢她的《再见》的 MV，哈哈\n年度电影： 寄生虫 复仇者联盟 4 流浪地球 今年最喜欢的是《流浪地球》，虽然还是免不了中国电影特有的有些令人尴尬的片段，但有笑点，大刘特有的科幻浪漫主义电影有表现了出来，感觉这些是好莱坞拍不出来的。本来还想去看下复映的《千与千寻》的，但最后都因一个人太懒没去成。。。\n年度图书： 今年没完整看过一本书。。。平时晚上回来就太累只看下 bilibili 了，明看要多看些书\n年度APP： Fxcnbeta 每天地铁上看科技新闻\n年度网站： bilibili 每天花的时间太多了，电视和手机上都装了 APP，\b在上面花了大量时间\n年度数码： Airpods Pro Airpods 前几年发布时就觉得是个革命性的产品，舒适无线好用，现在加上降噪后，就更完美了，只是佩戴的舒适性下降了，不过为了降噪，还是最强最好的无线蓝牙耳机\n","date":"2019-12-24T15:00:08+08:00","permalink":"https://blog.xenori.com/2019/12/the-summary-of-2019/","title":"The Summary of 2019"},{"content":"还有一天就到2018农历新年了，时间实在过得太快。今年两老的身体都有些不好，就提前请假回家，现在已舒服呆在房间中了。家里的天气实在是舒服，阳光明媚，想起广州住处的阴冷天气就头痛，衣服实在不容易干。\n文章的部分内容被密码保护：\nJavascript needs to be enabled to decrypt content 整理2017年的完成计划，发现还是有很多未完成：\n广州入户 学车 学游泳 学英语 入户从年初一直搞到年尾的11月份才搞完，被计生证和居住证卡了很长时间，还以为今年是办不了了，还好在10月份出了新政策——取消了计生证要求，居住证也侥幸通过审核了，剩下的就等8月份收楼后，迁到新房了：）\n学车学了几次就没动力了，开车要关注的太多了，还要养车。。。不过2018年会花多些时间学完，只要是方便接家人出去办事，到时再看下要不要买车位吧。\n今年感情上还是没大发展，一个人的确生活惯了，发现和人相处和追人实在没动力，感觉还有一点不想结婚。。。不过一个人生活病痛是个问题，12月份出现了一次剧烈的胃痛，当时真的痛到快晕过去了，但周围没人可以依靠带去医院，有时想，假如是遇到心脏抽搐的话，可能就一直没人发现了，唉。\n工作上也没大进展，维护的现有站点已经稳定了，技术上没什么挑战性，有些想离职，但现在年龄越来越大，找新的合适工作实在不容易，一年都在思考还适不适合做程序员，但找不到其他出路，有些想转做远程SOHO工作，但在中国不是太靠谱。\n新的一年，希望家人身体能健康快乐些，准备学下自己做饭，到下年春节可以自己来操劳下年夜饭。\n2017年年度选择如下：\n年度游戏： 塞尔达传说 荒野之息 绝地求生 发现今年是毕业工作以来想游戏最多的一年==！塞尔达传说应该是近10年来玩过最好玩的游戏了，冒险探索要素太强了，战斗系统也简单有深度，贡献了100+小时，现在还未打卡农，准备二周目再通关了。\n绝地求生绝对是今年PC的年度游戏，重新定义了“吃鸡”这个词，横扫了中国大片网吧。不过这游戏的游戏性真的很好，适合多种玩法，就算是一身烂枪技，靠拼头脑阴人也可以找到自己生存的方法，贡献了150+小时，还在玩中。。。\n年度动画： 少看新番了，今年没特别喜欢的\n年度音乐： Forerver Young How Long Will I Love You 音乐都是看电影或视频听到的\n年度电影： 疯狂原始人 盗钥匙的方法 / 鍵泥棒のメソッド 日本电影《盗钥匙的方法》是个小惊喜，实在没猜到结局：）\n年度图书： 无\n年度APP： 摩拜 智能手机发展了10年，地盘都分完了，今年新用上又火的就是共享单车了\n年度网站： bilibili 每天花的时间太多了，看了很多美食视频。。。\n年度数码： Nintendo Switch Airpods NS创意很好，今年游戏大作不断，玩得很开心。airpods是个革命性的产品（对无线便捷的产品我都特别有好感），除了戴起来太丑外，没其他缺点，方便实用，送礼佳品，超越了其他耳机厂商3~5年的技术实力。。。苹果顶呱呱\n","date":"2018-02-14T11:01:07+08:00","permalink":"https://blog.xenori.com/2018/02/the-summary-of-2017/","title":"The Summary of 2017"},{"content":"使用xhprof测试slim框架的性能时，发现php抛了Segment Fault错误，试着使用gdb查看是什么导致的。\n生成coredump文件 要生成php的coredump文件需要对系统进行一些配置，具体查看：Generating core-dump for php5-fpm\n使用gdb调试coredump文件 执行gdb命令，因为coredump是php-fpm进程生成的，还需要指定php-fpm的路径，要不查看不了具体的代码执行信息。\n$ gdb /usr/local/php5/sbin/php-fpm -c /tmp/core-php-fpm.1567 gdb调试命令 bt bt命令打印程序执行的堆栈信息\n(gdb) bt #0 _phpi_pop (ht=\u0026lt;value optimized out\u0026gt;, return_value=0x7faf756ace10, return_value_ptr=0x0, this_ptr=\u0026lt;value optimized out\u0026gt;, return_value_used=\u0026lt;value optimized out\u0026gt;, off_the_end=0) at /home/apps/php-5.6.10/ext/standard/array.c:1879 #1 0x00007faf7d8f3317 in hp_execute_internal (execute_data=0x7faf8991db40, fci=0x0, ret=1) at /home/apps/xhprof-master/extension/xhprof.c:1730 #2 0x0000000000888cc5 in zend_do_fcall_common_helper_SPEC (execute_data=\u0026lt;value optimized out\u0026gt;) at /home/apps/php-5.6.10/Zend/zend_vm_execute.h:560 #3 0x00000000008787d0 in execute_ex (execute_data=0x7faf8991db40) at /home/apps/php-5.6.10/Zend/zend_vm_execute.h:363 #4 0x00007faf7d8f2ca9 in hp_execute_ex (execute_data=0x7faf8991db40) at /home/apps/xhprof-master/extension/xhprof.c:1675 p p命令用于打印变量信息\n(gdb) p *executor_globals-\u0026gt;argument_stack $2 = {top = 0x7faf8991dc38, end = 0x7faf8993d848, prev = 0x0} f 切换当前的栈，一般来说，程序停止时，最顶层的栈就是当前栈\n# 切换到1层级的栈 (gdb) f 1 #1 0x00007f701d60c317 in hp_execute_internal (execute_data=0x7f702940a858, fci=0x0, ret=1) at /home/apps/xhprof-master/extension/xhprof.c:1730 1730\t((zend_internal_function *) execute_data-\u0026gt;function_state.function)-\u0026gt;handler( # 查看当前栈信息 (gdb) info f Stack level 1, frame at 0x7fff515e2090: rip = 0x7f701d60c317 in hp_execute_internal (/home/apps/xhprof-master/extension/xhprof.c:1730); saved rip 0x888a15 called by frame at 0x7fff515e2150, caller of frame at 0x7fff515e2040 source language c. Arglist at 0x7fff515e2038, args: execute_data=0x7f702940a858, fci=0x0, ret=1 Locals at 0x7fff515e2038, Previous frame\u0026#39;s sp is 0x7fff515e2090 Saved registers: rbx at 0x7fff515e2058, rbp at 0x7fff515e2060, r12 at 0x7fff515e2068, r13 at 0x7fff515e2070, r14 at 0x7fff515e2078, r15 at 0x7fff515e2080, rip at 0x7fff515e2088 info 查看信息\n# 打印局部变量信息 info locals # 打印全局和局部变量信息 info variables # 打印参数信息 info args # 打印当前堆栈信息 info f php脚本调试命令 使用php脚本调试命令，需要引入php源码中的脚本文件.gdbinit。\n(gdb) source /home/apps/php-5.6.10/.gdbinit zbacktrace zbacktrace可以打印php的堆栈信息，不同于bt只打印c的堆栈信息。\n(gdb) zbacktrace [0x7faf8991db40] array_shift(array(2)[0x7faf756acc88]) /var/www/html/php-framework-benchmark/slim-2.6/vendor/slim/slim/Slim/Slim.php:441 [0x7faf8991da18] Slim\\Slim-\u0026gt;mapRoute(array(2)[0x7faf897a0590]) /var/www/html/php-framework-benchmark/slim-2.6/vendor/slim/slim/Slim/Slim.php:473 [0x7faf8991d910] Slim\\Slim-\u0026gt;get(\u0026#34;/hello/index\u0026#34;, object[0x7faf897a0510]) /var/www/html/php-framework-benchmark/slim-2.6/index.php:18 print_cvs print_cvs打印当前执行命令下的所有php变量\nprintzv 打印zval变量信息，可指定zval的指针地址，如zbacktrace返回的函数参数地址\n(gdb) printzv 0x7faf756acc88 [0x7faf756acc88] (refcount=2,is_ref) array(2): { 0 =\u0026gt; [0x7faf8979ee40] (refcount=4) string(12): \u0026#34;/hello/index\u0026#34; 1 =\u0026gt; [0x7faf897a0510] (refcount=3) objectYou can\u0026#39;t do that without a process to debug. print_ht print_ht是用打印zval变量信息\nprint_htptr print_htptr是用打印zval指针指向的变量信息\nprint_htstr print_htstr用于打印string构成的Hashtable变量信息\nprint_ft print_ft用于打印function table (HashTable)\nzmemcheck zmemcheck用于显示当前的内在分配状态信息\nphp全局对象executor_globals php源码用有个用EG宏表示的全局对象executor_globals，它包含了php所有相关的执行信息，如当前执行的op_array，传递参数和函数名等信息。源码中的EG(v)实际是调用executor_globals-\u0026gt;v。executor_globals包含的变量有很多，可以用命令：\np executor_globals 打印出来查看。\n下面是比较重要的几个变量：\nargument_stack : 传递给当前调用函数的参数堆栈，可以查看参数信息 current_execute_data : 当前执行的命令信息，如当前执行函数信息，op_array，op_code等 prev_execute_data ：前一执行命令信息，相当于调用函数的上级函数 active_op_array : 当前正在执行的op_array exception : 当前包含的异常信息 查看示例：\n## 查看当前执行命令信息 (gdb) p *executor_globals-\u0026gt;current_execute_data $8 = {opline = 0x7faf76376fd0, function_state = {function = 0x1123720, arguments = 0x7faf8991dc30}, op_array = 0x7faf897bf9f8, object = 0x0, symbol_table = 0x0, prev_execute_data = 0x7faf8991da18, old_error_reporting = 0x0, nested = 0 \u0026#39;\\000\u0026#39;, original_return_value = 0x0, current_scope = 0x7faf8991da28, current_called_scope = 0x0, current_this = 0x0, fast_ret = 0x0, delayed_exception = 0x0, call_slots = 0x7faf8991dc08, call = 0x7faf8991dc08} ## 查看前一执行命令信息，相当于上级调用函数 (gdb) p *executor_globals-\u0026gt;current_execute_data-\u0026gt;prev_execute_data $19 = {opline = 0x7faf763781e8, function_state = {function = 0x7faf897bf9f8, arguments = 0x7faf8991dad8}, op_array = 0x7faf897bf020, object = 0x7faf8978adf0, symbol_table = 0x0, prev_execute_data = 0x7faf8991d910, old_error_reporting = 0x0, nested = 0 \u0026#39;\\000\u0026#39;, original_return_value = 0x0, current_scope = 0x7faf897c2d48, current_called_scope = 0x7faf897c2d48, current_this = 0x7faf8978adf0, fast_ret = 0x7faf897c2d48, delayed_exception = 0x0, call_slots = 0x7faf8991dab0, call = 0x7faf8991dab0} 扩展阅读 如何调试PHP的Core之获取基本信息\nTIPI: 深入理解PHP内核\n","date":"2015-07-08T01:33:35+08:00","permalink":"https://blog.xenori.com/2015/07/2015-using-gdb-to-debug-php-coredump/","title":"使用gdb调试php的coredump文件"},{"content":"近排开发的一个后台系统（域名：admin.test.test.com）在接入公司统一SSO时，遇到了cookie冲突引起的登录循环重定向的bug。\n公司有一个统一的SSO登录页面，我们开发的系统是跳转到该页面实现登录验证的。有用户反映登录不了，浏览器提示循环重定向了，查看用户浏览器发现有两个相同名称的session cookie：\nPHPSESSID=token1; path=/; expired=/; domain=.test.com PHPSESSID=token2; path=/; expired=/; domain=.test.test.com 显然这两个cookie的domain因为都是admin.test.test.com的根域名，使浏览器都发送到php后台系统了。第一个是后台系统（admin.test.test.com）写入的，是正确的session id，而第二个是由未知系统写入的。测试打印**$_COOKIE[\u0026lsquo;PHPSESSID\u0026rsquo;]**发现输出是：\ntoken2 很明显php读取到了错误的session id，所以导致系统读取不到保存在session中的登录信息，而误判用户为未登录，之后再把用户跳转回SSO登录页面，跳转回SSO系统后，SSO系统知道用户已登录过，再跳转回系统。。。这样就一直循环下去了=。=\n为什么PHP会读取到错误的session id呢？打印全局变量**$_SERVER[\u0026lsquo;HTTP_COOKIES\u0026rsquo;]**出来查看：\nPHPSESSID=token2;PHPSESSID=token1 发现PHP是能接收到两个同名COOKIE的，但只取了第一个当真正的session id！！\n查看php源码，在文件php_variables.c的220行，有注释出php对同名cookie的处理规则：\nhttps://github.com/php/php-src/blob/e10e151e9b92313a7085272c85bebf6c82017fce/main/php_variables.c #220\n/* * According to rfc2965, more specific paths are listed above the less specific ones. * If we encounter a duplicate cookie name, we should skip it, since it is not possible * to have the same (plain text) cookie name for the same path and we should not overwrite * more specific cookies with the less specific ones. */ if (Z_TYPE(PG(http_globals)[TRACK_VARS_COOKIE]) != IS_UNDEF \u0026amp;\u0026amp; symtable1 == Z_ARRVAL(PG(http_globals)[TRACK_VARS_COOKIE]) \u0026amp;\u0026amp; zend_symtable_str_exists(symtable1, index, index_len)) { zval_ptr_dtor(\u0026amp;gpc_element); } else { gpc_element_p = zend_symtable_str_update_ind(symtable1, index, index_len, \u0026amp;gpc_element); } 意思是当php遇到相同名称的cookie时，只会保留**$_SERVER[\u0026lsquo;HTTP_COOKIES\u0026rsquo;]**中的第一个cookie，而余下同名的会忽略跳过。\n很明显，只要浏览器传cookie给php时，把token1的session id放在最前面，这样就能正确判断登录成功了！ 那么浏览器传递cookie顺序是如何的呢？参考RFC6265 HTTP State Management Mechanism，可以发现：\n4.2.2 In particular,if the Cookie header contains two cookies with the same name (e.g., that were set with different Path or Domain attributes), servers SHOULD NOT rely upon the order in which these cookies appear in the header. 5.3. Storage Model 2. The user agent SHOULD sort the cookie-list in the following order: * Cookies with longer paths are listed before cookies with shorter paths. * Among cookies that have equal-length path fields, cookies with earlier creation-times are listed before cookies with later creation-times. NOTE: Not all user agents sort the cookie-list in this order, but this order reflects common practice when this document was written, and, historically, there have been servers that (erroneously) depended on this order. 大概意思就是：\npath越长的说明匹配越精确，顺序越靠前 假如path相同，cookie创建时间越早的，顺序越靠前 顺序与domain没关系\nRFC同时也说明并不是所有的浏览器都遵守这个，并且服务器也不应该依赖于cookie出现的顺序。 最后通过更改保存的session id名称来避免冲突解决问题，不过倒让我加深了cookie的了解。\n","date":"2015-04-02T00:21:00Z","permalink":"https://blog.xenori.com/2015/04/loop-redirect-cause-by-cookie-conflict/","title":"解决cookie冲突导致的登录循环重定向"},{"content":"2013年已过，过去一年生活和工作上没有大的变化。年前的计划如英语学习，学车和游戏等都没实现到，在广州现在没什么朋友和同学在，一个人执行力太差了，周六日随便找个偷懒的理由就混过了。。。\n今年在工作上是忙碍的一年，上半年忙于把CMS系统数据层切换到数据中心，下半年因公司上市，忙于把服务器从windows切换到linux，开发语言也从最熟悉的.NET转为使用PHP。这一年忙着工作，忙着加班，计划的旅游没去到，生活状态也是越过越差，而公司上市也没为收入带来什么收益，对公司有点失望透了。2014年工作准备把重心放回到生活中，不能被工作绑架了，太累了。\n年前因公司策略调整，开发语言变更，很多旧同事都在上半年离职，只剩下一两个人维护频道，下半年新同事陆陆续续入职，挣了半年，春节后应该就能回复到正轨了。不过现在发现怎样也融不进新团队，也不喜欢新团队气氛，只希望年后能找到不错的工作，换下环境。\n2014年就计划专业方面学下英语，golang和看多些开源代码，业余方面学下游泳和摄影。生活上希望能变得自信豁达些，让过去都过去吧。对于家人，因为从中学后就一个人出来住和生活，的确没花太多精力关注家人，希望今年能做得更好。\n2013年年度选择如下：\n年度游戏：\n旅行Travel 第二次超级机器人大战OG 今年工作太忙，对游戏的热情也下降了，就通了PSN游戏《旅行》，小时最喜欢的机器打了20话左右就不继续了。。。虽然不想承认，看来是过了喜欢游戏的年龄了。。。\n年度动画：\n石头门 进击的巨人 《石头门》比较惊喜，看画风是我一般不会云看的动画，但在bilibili上很多人推荐，花了一晚通宵看完，很喜欢。提名《kill la kill》\n年度音乐：\nRain piano ver. Feels Like Coming Home Everybody Hurts The Beginning あの日タイムマシン Let Her Go 音乐都是动画和视频的音乐，很多歌都是看bilibili视频找到的：）\n年度电影：\n疯狂原始人 盗钥匙的方法 / 鍵泥棒のメソッド 日本电影《盗钥匙的方法》是个小惊喜，实在没猜到结局：）\n年度图书： 无\n今年看书都转到多看了，基本不再买纸书，都是买电子版，不过没看到最特别印象深刻的。今年感觉在上班路上看了不少书，以技术书为主，但在豆瓣上看下来，也没多少==！\n年度APP：\npocket 知乎 多看 年度网站：\nbilibili 今年看电影，看新番基本都在bilibili看，开始喜欢上bilibi应该是去年一起看《舌尖上的中国》，很热闹，哈哈。之后看《爱情公寓3》，今年末的《爸爸去哪儿》也是不小的高潮。\n年度数码：\nMacbook Air RX100 MX2 air是为了工作上转linux准备的，但一年下来用得不多。。。MX2很喜欢，在国产手机中，魅族的UI和手机外形是最喜欢的了，比较iphone5好看，就是信号的确不好。\n","date":"2014-01-01T21:14:00+08:00","permalink":"https://blog.xenori.com/2014/01/the-summary-of-2013/","title":"2013年总结"},{"content":"预装编译环境 在ubuntu中执行下面命令安装编译依赖软件\n\u0026gt; sudo apt-get install \\ libxml2-dev \\ libcurl4-openssl-dev \\ libjpeg-dev \\ libpng-dev \\ libxpm-dev \\ libmysqlclient-dev \\ libpq-dev \\ libicu-dev \\ libfreetype6-dev \\ libldap2-dev \\ libxslt-dev 下载php源代码 wget http://us3.php.net/get/php-5.5.5.tar.gz/from/cn2.php.net/mirror 开始编译安装 \u0026gt; tar zxf php-5.5.5.tar.gz \u0026gt; cd php-5.5.5 \u0026gt; sudo ./configurate ... 安装apc和memcache扩展","date":"2013-11-12T01:07:00+08:00","permalink":"https://blog.xenori.com/2013/11/install-php-from-source-in-ubuntu/","title":"在ubuntu中编译安装php"},{"content":"php中有三个函数与捕捉运行错误有关，分别是：\nset_error_handler：运行错误处理函数，php内核执行代码出错时一般是触发error，而不是抛异常，抛异常是面向对象编程中用的\nset_exception_handler：运行异常信息处理函数，当代码中throw的异常没有被try-catch捕获时，就会调用该函数。php中error和exception的区别可以看这篇回答：php-exceptions-vs-errors\nregister_shutdown_function：脚本关闭执行函数，会在php脚本每次执行完成退出前运行。\n为了保证运行错误能被顺利捕捉到，必须保证在有错的程序执行前先注册了错误处理函数。 一般错误处理代码结构如下：\nfunction handle_normal_error($errno, $errstr, $errfile, $errline) { // 把error封装为异常，由异常处理函数统一处理 throw new ErrorException($errstr, 0, $errno, $errfile, $errline); // don\u0026#39;t execute php default exception action return true; } set_error_handler(\u0026#39;handle_normal_error\u0026#39;, E_ALL | E_STRICT); function user_exception_handler($ex) { switch ($errno) { case E_USER_ERROR: send_error_to_log_server($msg); break; case E_USER_WARNING: // do something break; default: // do something break; } } set_exception_handler(\u0026#39;user_exception_handler\u0026#39;); function handle_fatal_error() { $error = error_get_last(); if (isset($error[\u0026#39;type\u0026#39;]) \u0026amp;\u0026amp; E_ERROR == $error[\u0026#39;type\u0026#39;]) { send_error_to_log_server($msg); } } register_shutdown_function(\u0026#39;handle_fatal_error\u0026#39;); 在thinkphp 3.13中，已经做了全局导常处理，代码如下： {% codeblock Think.class.php %}\n/** * 应用程序初始化 * @access public * @return void */ static public function start() { // 设定错误和异常处理 register_shutdown_function(array(\u0026lsquo;Think\u0026rsquo;,\u0026lsquo;fatalError\u0026rsquo;)); set_error_handler(array(\u0026lsquo;Think\u0026rsquo;,\u0026lsquo;appError\u0026rsquo;)); set_exception_handler(array(\u0026lsquo;Think\u0026rsquo;,\u0026lsquo;appException\u0026rsquo;));\n... } /** * 自定义异常处理 * @access public * @param mixed $e 异常对象 */ static public function appException($e) { $error = array(); $error[\u0026lsquo;message\u0026rsquo;] = $e-\u0026gt;getMessage(); $trace = $e-\u0026gt;getTrace(); if(\u0026rsquo;throw_exception\u0026rsquo;==$trace[0][\u0026lsquo;function\u0026rsquo;]) { $error[\u0026lsquo;file\u0026rsquo;] = $trace[0][\u0026lsquo;file\u0026rsquo;]; $error[\u0026rsquo;line\u0026rsquo;] = $trace[0][\u0026rsquo;line\u0026rsquo;]; }else{ $error[\u0026lsquo;file\u0026rsquo;] = $e-\u0026gt;getFile(); $error[\u0026rsquo;line\u0026rsquo;] = $e-\u0026gt;getLine(); } Log::record($error[\u0026lsquo;message\u0026rsquo;],Log::ERR); halt($error); }\n/** * 自定义错误处理 * @access public * @param int $errno 错误类型 * @param string $errstr 错误信息 * @param string $errfile 错误文件 * @param int $errline 错误行数 * @return void */ static public function appError($errno, $errstr, $errfile, $errline) { switch ($errno) { case E_ERROR: case E_PARSE: case E_CORE_ERROR: case E_COMPILE_ERROR: case E_USER_ERROR: ob_end_clean(); // 页面压缩输出支持 if(C('OUTPUT_ENCODE')){ $zlib = ini_get('zlib.output_compression'); if(empty($zlib)) ob_start('ob_gzhandler'); } $errorStr = \u0026quot;$errstr \u0026quot;.$errfile.\u0026quot; 第 $errline 行.\u0026quot;; if(C('LOG_RECORD')) Log::write(\u0026quot;[$errno] \u0026quot;.$errorStr,Log::ERR); function_exists('halt')?halt($errorStr):exit('ERROR:'.$errorStr); break; case E_STRICT: case E_USER_WARNING: case E_USER_NOTICE: default: $errorStr = \u0026quot;[$errno] $errstr \u0026quot;.$errfile.\u0026quot; 第 $errline 行.\u0026quot;; trace($errorStr,'','NOTIC'); break; } } // 致命错误捕获 static public function fatalError() { // 保存日志记录 if(C('LOG_RECORD')) Log::save(); if ($e = error_get_last()) { switch($e['type']){ case E_ERROR: case E_PARSE: case E_CORE_ERROR: case E_COMPILE_ERROR: case E_USER_ERROR: ob_end_clean(); function_exists('halt')?halt($e):exit('ERROR:'.$e['message']. ' in \u0026lt;b\u0026gt;'.$e['file'].'\u0026lt;/b\u0026gt; on line \u0026lt;b\u0026gt;'.$e['line'].'\u0026lt;/b\u0026gt;'); break; } } } {% endcodeblock %}\n{% codeblock functions.php %}\n/**\n错误输出 @param mixed $error 错误 @return void */ function halt($error) { $e = array(); if (APP_DEBUG) { //调试模式下输出错误信息 if (!is_array($error)) { $trace = debug_backtrace(); $e[\u0026lsquo;message\u0026rsquo;] = $error; $e[\u0026lsquo;file\u0026rsquo;] = $trace[0][\u0026lsquo;file\u0026rsquo;]; $e[\u0026rsquo;line\u0026rsquo;] = $trace[0][\u0026rsquo;line\u0026rsquo;]; ob_start(); debug_print_backtrace(); $e[\u0026rsquo;trace\u0026rsquo;] = ob_get_clean(); } else { $e = $error; } } else { //否则定向到错误页面 $error_page = C(\u0026lsquo;ERROR_PAGE\u0026rsquo;); if (!empty($error_page)) { redirect($error_page); } else { if (C(\u0026lsquo;SHOW_ERROR_MSG\u0026rsquo;)) $e[\u0026lsquo;message\u0026rsquo;] = is_array($error) ? $error[\u0026lsquo;message\u0026rsquo;] : $error; else $e[\u0026lsquo;message\u0026rsquo;] = C(\u0026lsquo;ERROR_MESSAGE\u0026rsquo;); } } // 包含异常页面模板 include C(\u0026lsquo;TMPL_EXCEPTION_FILE\u0026rsquo;); exit; } {% endcodeblock %}\n","date":"2013-11-04T00:48:00+08:00","permalink":"https://blog.xenori.com/2013/11/handle-fatal-error-in-php/","title":"捕捉php中的fatal error错误"},{"content":"由于国内网络的原因，在安装ruby相关软件时，经常会在请求rubygems.org下载时一直卡着不动，这时可以切换到淘宝的镜像源，速度嗖嗖的。\nhttp://ruby.taobao.org/\n详细的更改方法可以访问上面的网址，假如项目下有GemFile文件，还需要更改GemFile文件的配置源地址。\nlinux操作系统包管理镜像站： centos、ubuntu等linux发行版的yum和apt包管理工具镜像站：\nhttp://mirrors.aliyun.com/\nhttp://mirrors.163.com/\n","date":"2013-07-15T00:15:00+08:00","permalink":"https://blog.xenori.com/2013/07/change-rubygem-source/","title":"更改rubygems镜像源"},{"content":"软件环境 继续下面的示例前，需要保证安装了下面的软件：\nJDK 1.6 Android SDK IntelliJ IDEA 12 Scala 2.10.2 Maven 3 IntelliJ IDEA 12正常也可以换为Android Studio，不过因为Android Studio是基于IntelliJ IDEA 13 EAP开发的，当前scala plugin还不支持13 EAP，所以还是建议使用IntelliJ IDEA 12，等scala plugin支持最新版后，再换为Android Studio进行开发。\n示例项目 hello-scaloid-maven是一个完全使用maven编译的示例项目,借助android maven plugin插件可以把代码编译为android的apk文件。\n1、下载hello scaloid maven项目到本地 {% codeblock lang:ruby %} git clone https://github.com/pocorall/hello-scaloid-maven.git hello-scaloid-maven {% endcodeblock %}\n2、打开POM.xml文件，在中加上Android SDK的本地路径 {% codeblock lang:xml %} \u0026lt;scala.version\u0026gt;2.10.2\u0026lt;/scala.version\u0026gt; \u0026lt;android.sdk.path\u0026gt;/Applications/android sdk/\u0026lt;/android.sdk.path\u0026gt; {% endcodeblock %}\n3、执行maven命令下载依赖软件 {% codeblock lang:ruby %} mvn clean package {% endcodeblock %}\n4、当提示build success后，用IntelliJ IDEA的“File-\u0026gt;Open Project”打开POM.xml文件。这里不建议直接使用mvn idea:idea命令生成的IntelliJ项目文件，因为IntelliJ一直在更新，而mvn生成的项目文件可能格式比较旧了。\n5、因为android不包括scala类库，所以编译时需要把scala和scaloid类库也编译到apk中，但一个apk是有方法数量限制的，当不使用Proguard进行裁减优化时，使用IntelliJ IDEA编译项目经常会提示错误： {% codeblock lang:ruby %} Android Dex: [hello-scaloid-maven] trouble writing output: Too many methods: 112662; max is 65536. By package: Android Dex: [hello-scaloid-maven] 2 android.annotation Android Dex: [hello-scaloid-maven] 32 android.gesture Android Dex: [hello-scaloid-maven] 48101 org.scaloid.common \u0026hellip; {% endcodeblock %}\n6、IntelliJ IDEA默认不打开Proguard，下面我们修改配置打开Proguard。打开“File-\u0026gt;Prject Structure-\u0026gt;Facets-\u0026gt;android-\u0026gt;compiler”，勾选上Enable ProGuard项。并把Config file指向项目根目录的proguard.cfg文件。\n注意：MAC下android sdk目录假如有空格的话，编译时会提示错误：\nUnable to access jarfile /Applications/Android 这时需要改下Proguard脚本。打开“$(android sdk path)/tools/proguard/bin/proguard.sh”文件，把“$PROGUARD_HOME/lib/proguard.jar”路径用双引号括起来。详细可参考：http://fiahfy.blogspot.com/2013/06/unable-to-access-jarfile.html\n7、设置好Proguard后，再使用IntelliJ IDEA编译应该就能成功了。Have fun！！\nTip：假如你觉得android模拟器太慢，可以参考这篇文章做优化，速度提高10倍！！https://www.virag.si/2012/10/speeding-up-android-emulator/\n","date":"2013-06-30T15:41:00+08:00","permalink":"https://blog.xenori.com/2013/06/develop-android-with-intellij-idea-12-and-scaloid/","title":"使用scala+scaloid+IntelliJ IDEA 12开发android应用"},{"content":"工作用电脑将会切换到ubuntu上了，记录下ubuntu常用操作。\n===升级到php5.4=== For Ubuntu 11.10/12.04: sudo add-apt-repository ppa:ondrej/php5 sudo apt-get update sudo apt-get install php5 For Ubuntu 10.04 LTS, run the following commands (Thanks to Ivan Castellanos for the extra tip): sudo echo \u0026quot;deb http://ppa.launchpad.net/ondrej/php5/ubuntu lucid main\u0026quot; \u0026gt;\u0026gt; /etc/apt/sources.list sudo echo \u0026quot;deb-src http://ppa.launchpad.net/ondrej/php5/ubuntu lucid main\u0026quot; \u0026gt;\u0026gt; /etc/apt/sources.list sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys E5267A6C sudo apt-get update sudo apt-get install php5 You can check if PHP 5.4.x is successfully installed with this command: php5 -v http://www.zimbio.com/Ubuntu+Linux/articles/D_AsJR2qAL6/How+Upgrade+PHP+5+4+Ubuntu\n===开启ubuntu的root帐号=== $ sudo passwd root [sudo] password for ramesh: Enter new UNIX password: Retype new UNIX password: passwd: password updated successfully http://www.thegeekstuff.com/2009/09/ubuntu-tips-how-to-login-using-su-command-su-gives-authentication-failure-error-message/\n===安装SSH连接服务=== sudo apt-get install openssh-server https://help.ubuntu.com/10.04/serverguide/openssh-server.html\n===apache卸载、nginx和php安装=== http://cc.ecjtu.net/posts/php-5-4-Nginx-ubuntu-make-install\nphp交互命令行：http://phpsh.org/\n","date":"2012-10-30T15:14:22Z","permalink":"https://blog.xenori.com/2012/10/ubuntu-daily/","title":"ubuntu日常操作"},{"content":"IDA Pro是一款强大的反汇编软件，特有的IDA视图和交叉引用，可以方便理解程序逻辑和快速定位代码片断，以方便修改。\n示例程序 下面会通过修改示例程序的输出字符串，来讲解如何使用IDA Pro。\n#include main() { int n; scanf (\u0026quot;%d\u0026quot;,\u0026amp;n); if (n \u0026gt; 0) printf(\u0026quot;a \u0026gt; 0\u0026quot;); //后面会用IDA Pro把'a'改成'n' else printf(\u0026quot;n \u0026lt; 0\u0026quot;); } 编译后的程序下载：demo\n运行IDA Pro 运行IDA Pro，并使用PE文件的方式打开示例的test.exe文件。IDA Pro会新建一个工程，并开始反汇编程序。反汇编完成后，在[IDA-View]窗口中，可以看到程序逻辑的树形图，如下：\n树形图把条件分支清晰地显示出来了，绿色线连着的表示条件为true时执行的逻辑，而红色线表示条件为false时执行的逻辑。右下角有IDA视图的缩略图，在上面点击可以快速定位到视图的指定位置。\nIDA的工具栏有几个按钮对定位代码很重要，如下图所示：\n从左到右分别是： Open exports window:打开导出窗口 Open import window:打开导入窗口 *Open names window:函数和参数的命名列表 *Open functions window:程序调用的所有函数窗口 *Open strings window: 打开字符串显示窗口，会列出程序中的所有字符串，该窗口有助于你通过程序的运行输出逆向找出对应的代码片断。\n定位代码片断 假设我们现在接到个任务，需修正程序，把输出“a \u0026gt; 0”修正为“n \u0026gt; 0”。示例程序比较简单，直接看IDA视图我们就能找到需修改的代码片断，但实际处理时，可能程序有几m大，通过一个个看IDA视图已没法有效找到相关的执行代码片断，这时怎么办？ 使用字符串窗口和IDA强大的交叉引用！ 点击工具栏的[Open strings windows]按钮，可以看到如下的程序字符串：\n程序的字符串较少，可以很快地看到我们需要的字符串“a \u0026gt; 0”在数据段00403003位置。假如字符串多到已不能肉眼定位查找，因为字符串窗口是没有查找功能的，这时需要借助其他的文本编辑器，如notepad，editplus等。在字符串窗口内右键，选择菜单[copy]命令，会把字符串窗口的所有内容复制到剪贴板，再粘贴到记事本中查找就可以了。\n双击字符串窗口的该行字符串，会跳转到IDA视图的00403003位置，如下图所示：\n该位置的字符串后面会注释有DATA XREF的字样，这是程序中引用到该字符串的代码片断的地址！在该行上右键，选择[Jump to cross reference\u0026hellip;]项，会立即跳转到引用该字符串的代码片断位置！\n最后定位的代码片断 上图显示的汇编指令即是我们要找的代码片断，这时点击[Hex View-A]窗口，会切换到二进制浏览模式，并高亮了汇编代码的二进制格式指令，如下图所示：\n已找到需修改的代码片断，剩下的只需把a改成n。\n修改程序文件 在IDA中，可以在[Hex View-A]窗口右键选择[Edit]来修改二进制指令。修改后通过右键选择[Commit Change]可以看到修改后的IDA视图。但需要注意的是，这种方式的修改并不会更新原始程序文件，实际只是修改了IDA的项目文件！IDA中只适合做一些验证性的修改，确保正确后再使用其他工具修改原始程序文件。 在IDA中验证修改正确后，可以使用UltraEdit或Hex Workshop来修改原始程序文件。下面会以UltraEdit为例来说明如何修改。\n用UltraEdit直接打开程序文件，UltraEdit会以16进制模式显示程序文件。UltraEdit显示的地址和IDA显示的地址是不同的，为了找到对应代码片断在UltraEdit中的实际地址，需要使用到UltraEdit的查找功能。在IDA中复制需修改的16进制模式显示的指令，在UltraEdit中打开查找，粘贴并查找该16进制字符串，UltrEdit会很快定位到该指令处，如下图所示：\n在IDA中使得右键来复制\n在UltraEdit打开查找功能\n找到了UltraEdit的对应位置\n现在我们要把“a \u0026gt; 0”改成“n \u0026gt; 0”，a对应的ASCII码是61，而n对应的ASCII码是6E，只需把61改成6E就可以了，修改后保存。\n再次运行，可以看到结果已改变！\n示例只是修改了字符串，只需更改数据段内容就可以了，不用更改指令。假如需要更改指令，需要参考http://courses.engr.illinois.edu/ece390/resources/opcodes.html#Main 8086指令操作表写出对应指今的16进制形式，再修改。\n参考资料： http://blog.csdn.net/liquanhai/article/details/5479141 http://www.youtube.com/watch?v=Gl2S0YPRb9s http://www.woodmann.com/crackz/Tutorials/Flores1.htm http://courses.engr.illinois.edu/ece390/resources/opcodes.html#Main http://faydoc.tripod.com/cpu/conventions.htm\n","date":"2012-05-16T16:30:16Z","permalink":"https://blog.xenori.com/2012/05/disassembly-with-ida-pro/","title":"利用IDA Pro反汇编程序"},{"content":"工作中发现一个公共组件因为某个类不带有[Serializable]特性，导致保存到memcache时出错。刚好负责的同事请假不在，尝试了iLSpy反编译方法后，最后决定使用Mono.Cecil直接修改现成的程序集dll解决。\n示例代码如下：\nclass Program { static void Main(string[] args) { var asmFile = \u0026quot;TestDll.dll\u0026quot;; // 程序集名 Console.WriteLine(\u0026quot;add serializable attribute for '{0}'.\u0026quot;, asmFile); var asmDef = AssemblyDefinition.ReadAssembly(asmFile, new ReaderParameters { ReadSymbols = true // 标识是否读取修改pdb文件 }); // 取类名中包含\u0026quot;Entity\u0026quot;字符串的类 var types = asmDef.Modules .SelectMany(m =\u0026gt; m.Types) .Where(t =\u0026gt; t.Name.Contains(\u0026quot;Entity\u0026quot;)); // 设置类为可序列化 foreach (var type in types) { type.IsSerializable = true; } // 重新保存dll var newAsmFileName = \u0026quot;TestDll_new.dll\u0026quot;; asmDef.Write(newAsmFileName, new WriterParameters { WriteSymbols = true }); Console.WriteLine(\u0026quot;new dll has save as {0}.\u0026quot;, newAsmFileName); } } Mono.Cecil除了可以更改特性，还能把sealed类更改为public类，功能非常强大。\n下载demo\n参考资料： 使用Mono.Cecil辅助ASP.NET MVC使用dynamic类型Model\n","date":"2012-05-12T08:31:49Z","permalink":"https://blog.xenori.com/2012/05/use-mono-cecil-to-change-dll-attribute/","title":"使用Mono.Cecil更改程序集dll特性"},{"content":"这是准备在每周技术分享会中分享的内容，但因为团队都忙于各种需求和服务器迁移，分享就一直搁置了。\n这个ppt还是有用心做的，如ppt的背景，和debug流程的箭头都是使用photoshop偷下来的= =！\n示例程序：Download Example\n","date":"2012-04-24T15:52:37Z","permalink":"https://blog.xenori.com/2012/04/windbg-tutorial/","title":"WinDbg入门"},{"content":"android模拟器默认的内部存储空间只有几十m，随便安装几个app就满了，google了下，发现AVD管理器是没有增加内部存储空间的设置的，要增加需要使用命令行来启动模拟器，命令如下：\nemulator -partition-size \u0026lt;size\u0026gt; -avd \u0026lt;virtual device name\u0026gt; 可以把命令保存到批处理bat文件中，以方便以后直接启动。\n使用命令行启动模拟器是不能使用snapshot功能的，创建的avd之前有启动的话，需要先关闭。 参考资料： https://groups.google.com/forum/?fromgroups#!topic/android-developers/wFO2HOcFiV4 http://developer.android.com/guide/developing/tools/emulator.html#startup-options\n","date":"2012-04-12T16:06:07Z","permalink":"https://blog.xenori.com/2012/04/android-internal-storage-space/","title":"增加Android模拟器的\"Internal Storage\"容量"},{"content":"StackOverflow上看到的解释WSGI如何工作的图（一图胜千言）： 相关： http://stackoverflow.com/questions/1303118/looking-for-a-diagram-to-explain-wsgi http://www.python.org/dev/peps/pep-0333/\n","date":"2012-03-26T15:41:54Z","permalink":"https://blog.xenori.com/2012/03/a-diagram-to-explain-wsgi/","title":"WSGI处理流程图"},{"content":"在微博上发现已有同学整理了一个不错的linux命令文档：http://115.com/file/c2rzrvw3#Unix-Linux 这篇文章等遇到好的命令再继续更新。。。\n文件命令 | 程序命令 | 网络命令 | 系统命令\n文件 创建一个文本文件\ntouch test.txt 删除文件\nrm -f text.txt 创建一个目录\nmkdir newdir 删除一个目录\nrm -r dirname 显示目录中的文件信息\nls -lt 改变文件或目录的权限\nchmod 666 test.txt 查看文件夹大小\ndu -h --max-depth=1 ./mp3 解压tar文件\ntar zxpf test.tar.gz 程序 安装程序\n显示正在运行的程序\nps -ef 关闭程序\nkill -QUIT [PID] 强制关闭程序\nkill -9 [PID] 网络 查看程序占用端口情况\nnetstat -anp -a显示所有连接，-n显示端口情况，-p显示程序PID\n系统 重启\nreboot 关机\npoweroff ","date":"2012-03-17T09:42:44Z","permalink":"https://blog.xenori.com/2012/03/linux-useful-commands/","title":"linux常用命令"},{"content":"工作中有时会碰到需要迁移数据库的时候，如更换机房，更换新服务器等。迁移数据库最重要是要确保正在运行的程序不会因为漏更改连接字符串而导致程序报错。但有时维护的项目可能老旧，没有相关维护文档，还有一些使用该数据库的windows服务也可能遍布在其他服务器上，这时我们该如何找到所有正在使用该数据库的服务呢？\n下面以windows服务器和Sql Server数据库为例，数据库服务器的ip是192.168.6.189，linux平台的思路差不多，只是命令有变化。\n1、查看Sql Server进程ID 打开任务管理器，点击“查看-\u0026gt;选择列”，勾选“PID(进程标识符)” 进程名称为“sqlservr.exe”的PID就是Sql Server的进程ID，当前是1800。\n2、查看当前连接Sql Server的服务器列表 打开命令行，输入下面的命令：\nnetstat -ano|find \u0026quot;1800\u0026quot; 结果如下：\nC:\\Documents and Settings\u0026gt;netstat -ano|find \u0026quot;1800\u0026quot; TCP 0.0.0.0:3758 0.0.0.0:0 LISTENING 1800 TCP 0.0.0.0:5025 0.0.0.0:0 LISTENING 1800 TCP 127.0.0.1:1434 0.0.0.0:0 LISTENING 1800 TCP 192.168.6.189:3758 192.168.6.76:2685 ESTABLISHED 1800 TCP 192.168.6.189:3758 192.168.6.76:2725 ESTABLISHED 1800 该命令会打印出所有连接到1800进程的服务器列表，可以看到192.168.6.76这台服务器正在连接到Sql Server。\n3、查看连接到数据库服务器的进程 进入服务器192.168.6.76，打开命令行，输入下面的命令：\nnetstat -ano |find \u0026quot;6.189\u0026quot; 6.189是数据库服务器的ip，find命令用来查找带有\u0026quot;6.189\u0026quot;字符串的行。输出如下：\nd:\\webroot\u0026gt;netstat -ano |find \u0026quot;6.189\u0026quot; TCP 192.168.6.76:2685 192.168.6.189:3758 ESTABLISHED 8520 TCP 192.168.6.76:2725 192.168.6.189:3758 ESTABLISHED 8520 结果最右边的就是正连接到数据库服务器的进程ID，当前是8520.现在已经找到进程了^0^，你只需打开任务管理器，看下该进程ID对应是进程是什么，就能准确定位了。\n4、查看IIS进程对应的站点 有时我们找到使用数据库的进程了，但是像IIS这种程序，因为所有站点的进程名都相同，所以无法准备定位了。 有什么方法可以找到w3wp.exe对应的站点名呢？可以使用iisapp命令：\nd:\\webroot\u0026gt;iisapp -a W3WP.exe PID: 6584 AppPoolId: test1.com W3WP.exe PID: 16304 AppPoolId: Special W3WP.exe PID: 8520 AppPoolId: test2.com W3WP.exe PID: 3164 AppPoolId: test3.com iisapp命令会输出W3WP进程对应的应用程序池名，通过应用程序池名我们就能准备定位站点：）\n","date":"2012-03-17T09:33:03Z","permalink":"https://blog.xenori.com/2012/03/find-who-connect-to-database/","title":"如何查看哪些进程和服务器正在使用数据库"},{"content":"IIS可以在一台服务器上配置多个web站点，每个站点通过ip地址、端口(port)和主机名(host)结合的标识符(ServerBindings Metabase)进行区分。标识字符串的格式如下：\nIP:Port:Hostname 上面的IP和Hostname是可选项，假如设定站点时不指定，表示匹配所有。\n主机名(Host Headers)是HTTP消息的一部分 浏览器和web服务器之间是通过http协议通信的。http发送的请求头部(headers)部分包含有很多信息，如Content-Length, Referer, Host等等。\n浏览器如何和web服务器通信 互联网上的两台主机之间是通过TCP/IP协议进行通信的，通信建立连接时需要指定ip和端口号(port)。当我们在浏览器中输入一个网站的域名，并按回车后，浏览器默认会使用http协议和80端口发出请求。\n浏览器首先需要把域名解析为对应的ip地址。域名解析可以使用dns服务器或本地的host文件。\n当域名解析为ip地址后，浏览器会和web服务器建立连接，并发出网页访问请求信息。请求信息的头部一般像下面这样：\nGET /index.htm HTTP/1.1 Host: www.ilopia.com IIS接收到请求后，会检查请求是否带有host信息(请求中也可能不带有host信息，如使用ip直接访问)。IIS发现有host后，会查找是否有匹配该host的站点，如果有匹配的站点，就会把请求路由给它进行处理。\n最后一步是IIS响应处理请求。\nIIS如何分发请求到指定web站点 IIS分发请求到指定站点的规则如下：\n1、是否存在准确匹配 IP:Port:Hostname标识字符串的站点，存在即分发请求，没有进行下一步匹配\n2、是否存在监听所有IP地址(站点设定时不指定)，并且Port和Hostname都匹配的站点，存在即分发请求，没有进行下一步匹配\n3、是否存在端口Port匹配，而IP和Hostname都未指定的站点，存在即分发请求，没有浏览器会提示没法连接到服务器\n参考资料 ServerBindings Metabase Property (IIS 6.0) Understanding Host Headers in IIS Using Host Headers to host multiple websites on IIS 6.0\n","date":"2012-03-03T17:00:18Z","permalink":"https://blog.xenori.com/2012/03/understanding-iis-host-headers/","title":"了解IIS的主机名(Host Headers)配置项"},{"content":"本人的ubuntu server版本是10.04.4，安装在免费的vmware player 4.0中。 安装vmware-tools需要gcc和对应的linux-headers进行编译，需先执行下面两个命令进行安装：\nsudo apt-get gcc sudo apt-get install build-essential linux-headers-$(uname -r) 安装后，点击vmware player菜单“Virtual Machine-\u0026gt;Install VMware Tools”，画面下方会出现黄色的VMware Tools安装提示框。 1、把安装光盘绑定到一个文件夹：\nmkdir /mnt/cdrom sudo mount /dev/cdrom /mnt/cdrom 2、解压安装文件到临时目录/tmp：\ncd /tmp tar zxpf /mnt/cdrom/VMwareTools-8.0.0-\u0026lt;xxxx\u0026gt;.tar.gz \u0026lt;/xxxx\u0026gt; 3、执行安装：\ncd vmware-tools-distrib sudo ./vmware-install.pl 4、之后按照安装提示，一直按Enter键确认就可以了。 5、安装后执行reboot重启：\nsudo reboot 参考资料： http://www.vmware.com/support/ws55/doc/ws_newguest_tools_linux.html#wp1127177 http://ubuntuforums.org/showthread.php?t=1561822 http://ubuntu-tutorials.com/2007/10/02/how-to-install-vmware-tools-on-ubuntu-guests/\n","date":"2012-02-19T08:07:01Z","permalink":"https://blog.xenori.com/2012/02/how-to-install-vmware-tools-in-ubuntu-server/","title":"如何在ubuntu server 10.04中安装vmware tools"},{"content":"Moles是由微软研究院(Microsoft Research)开发的.NET依赖分离框架，它实现了使用自定义的委托(delegate)方法来替换原有类中的方法，以达到分离依赖，方便单元测试的目的。Moles在功能和用法上与开源的IoC框架Moq很像，但Moles有一些Moq实现不了功能，如替换静态方法，去掉静态构造函数，突破访问限制等。Molas非常有利于对ASP.NET WebForm构建的网站和依赖第三方类库的程序进行单元测试。\n下载和安装 下载Moles后直接安装就可以了，里面集成有VS2010的插件，安装成功后，VS2010右键菜单中会集成Moles功能菜单。\n使用示例 我们试下测试2000年千年虫的bug。在VS2010中创建一个MoleDomain的类项目，并创建类Y2KChecker，代码如下：\nnamespace MoleDomain { public static class Y2KChecker { public static void Check() { if (DateTime.Now == new DateTime(2000, 1, 1)) throw new ApplicationException(\u0026quot;y2kbug!\u0026quot;); } } } 现在我们要测试这段代码，确定当时间为2000/1/1时，程序能正确抛出异常。很显然这段代码没法做单元测试，因为代码中的DateTime.Now是依赖系统时钟的，只返回当前时间，我们没法改变它的值使它刚好等于2000/1/1。怎么办好呢？\n使用Molas解决这个问题很简单。创建一个测试项目，并引用MoleDomain项目，单元测试代码如下：\n[TestMethod] [ExpectedException(typeof(ApplicationException))] public void Test() { Y2KChecker.Check(); } 运行测试，会显示预期的未通过，因为DateTime.Now现在返回的还是系统时间。 我们试下使用Molas替换DateTime.Now的返回值，在测试项目引用列表中，右键MoleDomain，选择“Add Moles Assembly”，确定后会自动在项目中增加一个MoleDomain.moles文件，moles后缀的文件是让Moles对该程序集自动生成对应的Molas类型程序集，以便测试时使用。 右键测试项目，选择“重新生成”，会发现程序自动引用了很多Moles相关的程序集，如Microsoft.Moles.Framework，还有自动生成的 MolaDomain.Moles程序集。 要使Moles正常运行，需要改下原来的单元测试代码。在测试方法上方加上HostType特性，并写下替换DateTime.Now返回值的代码：\n[TestMethod] [ExpectedException(typeof(ApplicationException))] [HostType(\u0026quot;Moles\u0026quot;)] public void Test() { //利用委托替换原来的返回值 MDateTime.NowGet = () =\u0026gt; new DateTime(2000, 1, 1); Y2KChecker.Check(); } 再次运行测试，发现还是失败，提示错误：\n测试方法 MoleDomain.Test.Y2KCheckerTest.Test 引发了异常 Microsoft.Moles.Framework.Moles.MoleNotInstrumentedException，但应为异常 System.ApplicationException。异常消息: Microsoft.Moles.Framework.Moles.MoleNotInstrumentedException: The System.DateTime System.DateTime.get_Now() was not instrumented To resolve this issue, add the following attribute in the test project: using Microsoft.Moles.Framework; [assembly: MoledType(typeof(System.DateTime))] 提示缺少一些引用配置，在测试命名空间上方加上代码：\nusing Microsoft.Moles.Framework; [assembly: MoledType(typeof(System.DateTime))] namespace MoleDomain.Test { ..... } 再次运行测试，终于通过测试了：） Mole基础知识 原始类成员方法对应的Mole类型属性如下：\n◇ 静态方法表示为mole类型的静态属性\n◇ 类实例方法表示为嵌套的AllInstances类型的静态属性\n◇ 类构造函数表示为mole类型的命名为Constructor的静态属性\n下面部分说明下如何使用. Static Methods 为mole类型的静态属性附加委托方法可以替换类静态方法的内容。mole类型属性只能附加一个委托方法。如MyClass类有一个静态方法MyMethod：\npublic static class MyClass { public static int MyMethod() { ... } } 我们附加一个mole到MyMethod中，使它一直返回5：\nMMyClass.MyMethod = () =\u0026gt;5; 自动生成的MMyClass类型的代码结构如下：\npublic class MMyClass { public static Func MyMethod { set { ... } } } 安装Moles框架后，使用右键的“Add Moles Assembly”功能添加.mole后缀文件后，MMyClass就能自动生成。\n实例方法(对所有实例生效) 和静态方法相似，也可以对所有实例方法进行mole。实例方法放置在嵌套类AllInstances的静态属性中，例如下面MyClass实例的MyMethod方法：\npublic class MyClass { public int MyMethod() { ... } } mole一个方法使所有实例对象都返回5：\nMMyClass.AllInstances.MyMethod = _ =\u0026gt; 5; 自动生成的MMyClass结构如下：\npublic class MMyClass : MoleBase { public static class AllInstances { public static FuncMyMethod { set { ... } } } } 实例方法(对一个实例生效) 对不同的实例，实例方法可以mole不同的委托方法。mole的属性实际是mole类型实例自己的属性（不是静态方法)，每个mole类型实例都会有一个原始类型的实例对象。如MyClass的实例方法MyMethod：\npublic class MyClass { public int MyMethod() { ... } } 我们可以创建两个MMyClass的实例对象，一个使它返回5，另一个使它返回10：\nvar myClass1 = new MMyClass() { MyMethod = () =\u0026gt; 5 }; var myClass2 = new MMyClass() { MyMethod = () =\u0026gt; 10 }; 自动生成的mole类型代码结构如下：\npublic class MMyClass : MoleBase { public Func MyMethod { set { ... } } public MyClass Instance { get { ... } } } 原始类型对象可以通过mole实例对象的Instance属性获得：\nvar mole = new MMyClass(); var instance = mole.Instance; mole实例对象也可以隐式转换为原始类型对象，所以你可以直接赋值对原始类型，如下：\nvar mole = new MMyClass(); MyClassinstance = mole; 构造函数(Constructors) 类构造函数也可以mole来进行一些赋值操作。类构造函数表示为mole类型的静态方法Constructor，如下面的MyClass类带有一个int参数的构造函数：\npublic class MyClass { public MyClass(int value) { this.Value = value; } ... } 通过附加构造函数使以后的所有实例的Value属性都返回-5：\nMMyClass.ConstructorInt32 = (@this, value) =\u0026gt; { var mole = new MMyClass(@this) { ValueGet = () =\u0026gt; -5 }; }; 如果你只想mole后面一个实例，我们只需把Constructor静态属性赋null值，如：\nMMyClass.ConstructorInt32 = (@this, value) =\u0026gt; { ... MMyClass.ConstructorInt32 = null; }; 需要注意的是，每个mole类型都有两个构造函数，当需要一个新的mole实例对象时，使用默认的构造器；而带有一个原始类型参数的构造函数，只应该在mole构造函数时使用。\npublic MMyClass() { } public MMyClass(MyClass instance) : base(instance) { } 自动生成的MMyClass代码结构如下：\npublic class MMyClass : MoleBase { public static Action ConstructorInt32 { set { ... } } public MMyClass() { } public MMyClass(MyClass instance) : base(instance) { } ... } 基类成员(Base Members) 只要把子类实例作为基类构造函数的参数传入，就可以创建一个基类的mole对象，并访问到基类中的mole属性。例如，基类Base有一个MyMethod的方法，而Child是Base的子类：\npublic abstract class Base { public int MyMethod() { ... } } public class Child : Base { } 通过创建一个MBase对象我们能设置Base的mole属性：\nvar child = new MChild(); new MBase(child) { MyMethod = () =\u0026gt; 5 }; 注意这里，当MChild实例作为传入MBase构造函数时，会被隐式转换为Child实例。 MChild和MBase的自动生成代码如下：\npublic class MChild : MoleBase { public MChild() { } public MChild(Child child) : base(child) { } } public class MBase : MoleBase { public MBase(Base target) { } public Func MyMethod { set { ... } } } 静态构造函数 静态构造函数在Moles中被特殊对待，Moles只能简单地抹去静态构造函数，而不能重新为它附加新的委托方法。Moles通过指定[MolesEraseStaticConstructor]特性来抹去一个类的静态构造函数。\n[assembly: MolesEraseStaticConstructor(typeof(MyStatic))] class MyStatic { static MyStatic() { throw new Exception(); // needs moling… } } 终结器(Finalizers) 对于终结器，Moles也是特殊对待的。Moles也是只能简单抹去终结器，通过指定[MolesEraseFinalizer]特性实现。\n[assembly: MolesEraseFinalizer(typeof(MyFinalizer))] class MyFinalizer { ~MyFinalizer() { throw new Exception(); // needs moling… } } 私有方法 假如私有方法的签名类型是可见的，Moles会为私有方法自动生成mole属性。签名类型可见是指，参数类型或返回值类型是可见的，不是私有类型。\n绑定接口 当类有实现接口时，Moles自动生成的mole类型会提供立即绑定接口成员的方法。例如，MyClass实现了s IEnumerable接口：\npublic class MyClass : IEnumerable { public IEnumerator GetEnumerator() { ... } ... } 通过mole类型的Bind方法，我们可以简捷地mole接口实现：\nvar myClass = new MMyClass(); myClass.Bind(new int[] { 1, 2, 3 }); 自动生成的MMyClass代码结构如下：\npublic class MMyClass : MoleBase { public MMyClass Bind(IEnumerable target) { ... } } Moles缺点 Moles缺点是，测试运行比较慢，还有测试代码只能在本机上才能测试通过，假如同伴获取代码后需要运行单元测试，必须也安装Molas环境。\n参考资料 http://research.microsoft.com/en-us/projects/pex/molesmanual.pdf\nhttp://research.microsoft.com/en-us/projects/pex/documentation.aspx\n","date":"2012-02-14T17:29:51Z","permalink":"https://blog.xenori.com/2012/02/molas-isolation-framework/","title":"Molas——.NET依赖分离框架"},{"content":"前一篇文章介绍了WinDbg入门，本篇主要介绍WinDbg常用命令和用法。\n调试程序的CPU满载问题，关键是要知道程序当前正在进行什么操作。假如我们在cpu满载时创建了一个dump文件，使用下面几个命令可以查看当前程序正在进行什么处理： .time 运行.time命令会显示时间相关的信息，如系统运行时间，进程运行时间和CPU花费在内核态和用户态的时间。\n0:000\u0026gt; .time Debug session time: Tue Oct 23 08:38:35.000 2007 (GMT+1) System Uptime: 4 days 17:48:01.906 Process Uptime: 0 days 0:24:37.000 Kernel time: 0 days 0:04:23.000 User time: 0 days 0:03:28.000 你可以看到系统已正常运行超过4天，进程运行了24分钟，CPU在内核态和用户态累积使用了8分钟。根据进程时间和CPU时间能大概估算出CPU使用率平均值是32.5%。\n!threadpool\n****通过!threadpool命令我们能准确知道创建dump时cpu的使用率。也能知道在队列中的待处理请求数，Completion Port(IOCP)线程数和定时器time数。\n0:000\u0026gt; !threadpool CPU utilization 100% Worker Thread: Total: 5 Running: 4 Idle: 1 MaxLimit: 200 MinLimit: 2 Work Request in Queue: 16 Unknown Function: 6a2d945d Context: 023ede30 Unknown Function: 6a2d945d Context: 023ee1e8 AsyncTimerCallbackCompletion TimerInfo@11b53760 Unknown Function: 6a2d945d Context: 023ee3a8 Unknown Function: 6a2d945d Context: 023e3040 Unknown Function: 6a2d945d Context: 023ee178 Unknown Function: 6a2d945d Context: 023edfb0 AsyncTimerCallbackCompletion TimerInfo@11b36428 AsyncTimerCallbackCompletion TimerInfo@11b53868 Unknown Function: 6a2d945d Context: 023ee060 Unknown Function: 6a2d945d Context: 023ee290 Unknown Function: 6a2d945d Context: 023eded0 Unknown Function: 6a2d945d Context: 023edd88 Unknown Function: 6a2d945d Context: 023ede98 Unknown Function: 6a2d945d Context: 023ee258 Unknown Function: 6a2d945d Context: 023edfe8 -------------------------------------- Number of Timers: 9 -------------------------------------- Completion Port Thread:Total: 3 Free: 3 MaxFree: 4 CurrentLimit: 2 MaxLimit: 200 MinLimit: 2 我们可以看到当前CPU已100%使用率，我们进入下一命令。\n!runaway\n这个命令用于显示所有正在运行的线程和它们的CPU使用率。这个命令对于查找高CPU使用率问题很有帮助！\n0:000\u0026gt; !runaway User Mode Time Thread Time 25:1a94 0 days 0:00:39.937 16:1bc0 0 days 0:00:38.390 50:1e8c 0 days 0:00:08.859 52:1e40 0 days 0:00:08.687 20:1c2c 0 days 0:00:08.234 51:1340 0 days 0:00:08.171 21:1bcc 0 days 0:00:06.953 26:13ec 0 days 0:00:06.671 44:131c 0 days 0:00:03.906 22:d8c 0 days 0:00:03.375 33:78c 0 days 0:00:02.656 34:1a8c 0 days 0:00:00.906 29:1f5c 0 days 0:00:00.828 6:e28 0 days 0:00:00.625 5:1c78 0 days 0:00:00.546 23:14a4 0 days 0:00:00.484 4:5ac 0 days 0:00:00.437 45:5dc 0 days 0:00:00.421 3:13b4 0 days 0:00:00.421 47:19c8 0 days 0:00:00.375 28:1b6c 0 days 0:00:00.250 46:1dac 0 days 0:00:00.156 7:1dd8 0 days 0:00:00.109 48:cdc 0 days 0:00:00.093 49:1eac 0 days 0:00:00.062 15:1a64 0 days 0:00:00.062 0:1804 0 days 0:00:00.046 36:4a4 0 days 0:00:00.031 11:1eb4 0 days 0:00:00.031 1:10b4 0 days 0:00:00.031 31:16ac 0 days 0:00:00.015 14:4ac 0 days 0:00:00.015 2:186c 0 days 0:00:00.015 59:590 0 days 0:00:00.000 58:294 0 days 0:00:00.000 57:16d0 0 days 0:00:00.000 56:1578 0 days 0:00:00.000 55:1428 0 days 0:00:00.000 54:16d8 0 days 0:00:00.000 53:fd8 0 days 0:00:00.000 43:1b8c 0 days 0:00:00.000 42:1c24 0 days 0:00:00.000 41:1e2c 0 days 0:00:00.000 40:11b0 0 days 0:00:00.000 39:edc 0 days 0:00:00.000 38:1a08 0 days 0:00:00.000 37:171c 0 days 0:00:00.000 35:1254 0 days 0:00:00.000 32:1f9c 0 days 0:00:00.000 30:1ae8 0 days 0:00:00.000 27:190c 0 days 0:00:00.000 24:1d2c 0 days 0:00:00.000 19:1e38 0 days 0:00:00.000 18:ee4 0 days 0:00:00.000 17:fb8 0 days 0:00:00.000 13:1b54 0 days 0:00:00.000 12:1a48 0 days 0:00:00.000 10:f64 0 days 0:00:00.000 9:1024 0 days 0:00:00.000 8:1b78 0 days 0:00:00.000 你可以看到运行线程的总时间和使用.time命令看到的总cpu使用时间并不相等。原因很简单，因为线程被重复使用或回收了。这也意味着一个线程的CPU使用时间可能是处理多个请求的结果。\n!threads\n!threads显示当前所有的托管线程信息。输出如下：\n0:000\u0026gt; !threads ThreadCount: 48 UnstartedThread: 0 BackgroundThread: 29 PendingThread: 0 DeadThread: 19 Hosted Runtime: no PreEmptive GC Alloc Lock ID OSID ThreadOBJ State GC Context Domain Count APT Exception 16 1 1bc0 001fccd0 1808220 Enabled 00000000:00000000 0019daf0 0 Ukn (Threadpool Worker) 22 2 d8c 002016f0 b220 Enabled 00000000:00000000 0019daf0 0 MTA (Finalizer) 14 4 4ac 00242e58 880a220 Enabled 00000000:00000000 0019daf0 0 MTA (Threadpool Completion Port) 23 5 14a4 11b39f18 80a220 Enabled 00000000:00000000 0019daf0 0 MTA (Threadpool Completion Port) 24 6 1d2c 11b41ad8 1220 Enabled 00000000:00000000 0019daf0 0 Ukn 25 7 1a94 11b46c70 180b220 Enabled 27240c98:27241fd8 11b42540 1 MTA (Threadpool Worker) 26 9 13ec 12ce2888 200b220 Enabled 2a9f1434:2a9f33c0 11b42540 0 MTA 27 a 190c 12d85eb8 200b220 Enabled 00000000:00000000 11b42540 0 MTA 29 b 1f5c 13df6a50 200b220 Enabled 2ab1da6c:2ab1f1c0 11b42540 0 MTA 30 c 1ae8 12d44a58 b220 Enabled 00000000:00000000 11b42540 0 MTA 31 d 16ac 12e2e008 200b220 Enabled 2a81348c:2a8153c0 11b42540 1 MTA 5 e 1c78 12da2160 220 Enabled 00000000:00000000 0019daf0 0 Ukn 33 8 78c 11b674c8 200b220 Enabled 2707b818:2707c1d8 11b42540 0 MTA 34 12 1a8c 13f163c8 220 Enabled 00000000:00000000 0019daf0 0 Ukn 36 13 4a4 13eef718 200b220 Enabled 2a7db4a4:2a7dd3c0 11b42540 0 MTA 4 14 5ac 13ef2008 220 Enabled 00000000:00000000 0019daf0 0 Ukn 42 10 1c24 13f0e950 880b220 Enabled 00000000:00000000 0019daf0 0 MTA (Threadpool Completion Port) 6 11 e28 13f16008 220 Enabled 00000000:00000000 0019daf0 0 Ukn 3 f 13b4 13eba008 220 Enabled 00000000:00000000 0019daf0 0 Ukn 43 15 1b8c 140db008 880b220 Enabled 00000000:00000000 0019daf0 0 MTA (Threadpool Completion Port) 44 17 131c 140ceb28 200b220 Enabled 272288c8:27229fd8 11b42540 0 MTA 45 1d 5dc 140cd0a0 220 Enabled 00000000:00000000 0019daf0 0 Ukn 47 20 19c8 1651a008 220 Enabled 00000000:00000000 0019daf0 0 Ukn XXXX 24 0 16468880 1801820 Enabled 00000000:00000000 0019daf0 0 Ukn (Threadpool Worker) 46 1f 1dac 1650ab48 220 Enabled 00000000:00000000 0019daf0 0 Ukn XXXX 1a 0 140d5008 1801820 Enabled 00000000:00000000 0019daf0 0 Ukn (Threadpool Worker) XXXX 16 0 140c5008 1801820 Enabled 00000000:00000000 0019daf0 0 Ukn (Threadpool Worker) 50 3 1e8c 14064420 180b220 Enabled 27246f54:27247fd8 11b42540 1 MTA (Threadpool Worker) XXXX 35 0 1406e800 1801820 Enabled 00000000:00000000 0019daf0 0 Ukn (Threadpool Worker) 51 36 1340 140df008 180b220 Enabled 2adec9cc:2aded1c0 11b42540 1 MTA (Threadpool Worker) XXXX 37 0 16566868 1801820 Enabled 00000000:00000000 0019daf0 0 Ukn (Threadpool Worker) 48 38 cdc 16578840 220 Enabled 00000000:00000000 0019daf0 0 Ukn XXXX 39 0 16566c28 1801820 Enabled 00000000:00000000 0019daf0 0 Ukn (Threadpool Worker) XXXX 3b 0 1646b8b0 1801820 Enabled 00000000:00000000 0019daf0 0 Ukn (Threadpool Worker) XXXX 3c 0 16674008 1801820 Enabled 00000000:00000000 0019daf0 0 Ukn (Threadpool Worker) XXXX 3d 0 16676418 1801820 Enabled 00000000:00000000 0019daf0 0 Ukn (Threadpool Worker) XXXX 3e 0 16676fb8 1801820 Enabled 00000000:00000000 0019daf0 0 Ukn (Threadpool Worker) XXXX 3f 0 16674d48 1801820 Enabled 00000000:00000000 0019daf0 0 Ukn (Threadpool Worker) XXXX 40 0 1667de10 1801820 Enabled 00000000:00000000 0019daf0 0 Ukn (Threadpool Worker) XXXX 41 0 16680050 1801820 Enabled 00000000:00000000 0019daf0 0 Ukn (Threadpool Worker) XXXX 42 0 166812e8 1801820 Enabled 00000000:00000000 0019daf0 0 Ukn (Threadpool Worker) XXXX 43 0 16683e60 1801820 Enabled 00000000:00000000 0019daf0 0 Ukn (Threadpool Worker) 52 44 1e40 165259e8 180b220 Enabled 2adf126c:2adf31c0 11b42540 1 MTA (Threadpool Worker) XXXX 45 0 165b7c08 1801820 Enabled 00000000:00000000 0019daf0 0 Ukn (Threadpool Worker) XXXX 46 0 165aa3d8 1801820 Enabled 00000000:00000000 0019daf0 0 Ukn (Threadpool Worker) XXXX 47 0 165242c8 1801820 Enabled 00000000:00000000 0019daf0 0 Ukn (Threadpool Worker) XXXX 48 0 165e9500 1801820 Enabled 00000000:00000000 0019daf0 0 Ukn (Threadpool Worker) 49 3a 1eac 165676f0 220 Enabled 00000000:00000000 0019daf0 0 Ukn 线程ID为XXXX表示该线程已结束，并在等待回收。我们也能看到线程ID为22的线程正在终结(finalizer)。假如我们使用!runaway命令时看到22线程有大量的cpu活动，可能我们的程序有终结(finalizer)问题。\n切换到指定线程\n要切换到指定的线程，可以使用下面的格式命令：~[thread id]s，假如我们要切换到50线程，命令如下：\n0:000\u0026gt; ~50s 现在我们已切换到线程50，可以使用很多其他有用的命令。\n!clrstack !clrstack显示当前线程的堆栈信息，通过指定“-p”参数，还能看到方法调用的参数和局部变量信息。 下面是线程50的堆栈信息：\n0:050\u0026gt; !clrstack OS Thread Id: 0x1e8c (50) ESP EIP 17a9e750 7d61c828 [NDirectMethodFrameSlim: 17a9e750] System.DirectoryServices.Protocols.Wldap32.ldap_bind_s(IntPtr, System.String, System.DirectoryServices.Protocols.SEC_WINNT_AUTH_IDENTITY_EX, System.DirectoryServices.Protocols.BindMethod) 17a9e768 14df70f9 System.DirectoryServices.Protocols.LdapConnection.BindHelper(System.Net.NetworkCredential, Boolean) 17a9e794 14df6de0 System.DirectoryServices.Protocols.LdapConnection.Bind() 17a9e79c 14df59e9 System.DirectoryServices.Protocols.LdapConnection.SendRequestHelper(System.DirectoryServices.Protocols.DirectoryRequest, Int32 ByRef) 17a9e8b8 14df56e8 System.DirectoryServices.Protocols.LdapConnection.SendRequest(System.DirectoryServices.Protocols.DirectoryRequest, System.TimeSpan) 17a9e8bc 14df5657 [InlinedCallFrame: 17a9e8bc] 从下向上看，我们能知道LdapConnection调用了SendRequest方法，而SendRequest又调用了SendRequestHelper方法等等。 如果我们执行“!clrstack -p”命令，我们得到信息：\n0:050\u0026gt; !clrstack -p OS Thread Id: 0x1e8c (50) ESP EIP 17a9e750 7d61c828 [NDirectMethodFrameSlim: 17a9e750] System.DirectoryServices.Protocols.Wldap32.ldap_bind_s(IntPtr, System.String, System.DirectoryServices.Protocols.SEC_WINNT_AUTH_IDENTITY_EX, System.DirectoryServices.Protocols.BindMethod) 17a9e768 14df70f9 System.DirectoryServices.Protocols.LdapConnection.BindHelper(System.Net.NetworkCredential, Boolean) PARAMETERS: this = 0x271fdfe0 newCredential = needSetCredential = 17a9e794 14df6de0 System.DirectoryServices.Protocols.LdapConnection.Bind() PARAMETERS: this = 17a9e79c 14df59e9 System.DirectoryServices.Protocols.LdapConnection.SendRequestHelper(System.DirectoryServices.Protocols.DirectoryRequest, Int32 ByRef) PARAMETERS: this = 0x271fdfe0 request = 0x27246e38 messageID = 0x17a9e8ec 17a9e8b8 14df56e8 System.DirectoryServices.Protocols.LdapConnection.SendRequest(System.DirectoryServices.Protocols.DirectoryRequest, System.TimeSpan) PARAMETERS: this = 0x271fdfe0 request = 0x27246e38 requestTimeout = 17a9e8bc 14df5657 [InlinedCallFrame: 17a9e8bc] 我们可以看到DirectoryRequest参数传递给了SendRequest和SendRequestHelper，要查看DirectoryRequest的相关信息，我们只需复制它的地址（0x27246e38），并在下个命令中使用。\n!dumpobject (!do) 这是另外一个重要的命令。Dumpobject会打印出指定地址的对象的相关信息。我们使用刚才的地址试下:\n0:050\u0026gt; !do 0x27246e38 Name: System.DirectoryServices.Protocols.SearchRequest MethodTable: 14b394c4 EEClass: 14d97ce0 Size: 52(0x34) bytes GC Generation: 0 (C:\\WINDOWS\\assembly\\GAC_MSIL\\System.DirectoryServices.Protocols\\2.0.0.0__b03f5f7f11d50a3a\\System.DirectoryServices.Protocols.dll) Fields: MT Field Offset Type VT Attr Value Name 02c39310 4000102 4 System.String 0 instance 00000000 directoryRequestID 14b398bc 4000103 8 ...ControlCollection 0 instance 27246e90 directoryControlCollection 02c39310 4000111 c System.String 0 instance 27246d00 dn 12579f5c 4000112 10 ....StringCollection 0 instance 27246eb4 directoryAttributes 02c36ca0 4000113 14 System.Object 0 instance 27246ddc directoryFilter 14b39344 4000114 18 System.Int32 1 instance 1 directoryScope 14b393fc 4000115 1c System.Int32 1 instance 0 directoryRefAlias 0fd3da00 4000116 20 System.Int32 1 instance 0 directorySizeLimit 1202af88 4000117 28 System.TimeSpan 1 instance 27246e60 directoryTimeLimit 120261c8 4000118 24 System.Boolean 1 instance 0 directoryTypesOnly 通过打印的信息，可以知道它是System.DirectoryServices.Protocols.SearchRequest的一个对象，而显示的都是 System.DirectoryServices.Protocols.SearchRequest的属性值。要知道SearchRequest类的相关属性信息，可以查看MSDN。当前我们已有RequestId, Scope和DistinguishedName等等。 所以，假如我们想知道SearchRequest对象的DistinguishedName属性值，即是上面列表中的dn，我们只需再复制它的地址（27246d00），并再次使用!dumpobject命令。因为DistinguishedName是System.String类型，所以输出结果很明显：\n0:050\u0026gt; !do 27246d00 Name: System.String MethodTable: 02c39310 EEClass: 0fb610ac Size: 112(0x70) bytes GC Generation: 0 (C:\\WINDOWS\\assembly\\GAC_32\\mscorlib\\2.0.0.0__b77a5c561934e089\\mscorlib.dll) String: CN=Dummy,CN=Accounts,CN=useradm,DC=dummy,DC=net Fields: MT Field Offset Type VT Attr Value Name 0fd3da00 4000096 4 System.Int32 1 instance 48 m_arrayLength 0fd3da00 4000097 8 System.Int32 1 instance 47 m_stringLength 0fb80010 4000098 c System.Char 1 instance 43 m_firstChar 02c39310 4000099 10 System.String 0 shared static Empty \u0026gt;\u0026gt; Domain:Value 0019daf0:03380310 11b42540:03380310 \u0026lt;\u0026lt; 0fb86d44 400009a 14 System.Char[] 0 shared static WhitespaceChars \u0026gt;\u0026gt; Domain:Value 0019daf0:03380324 11b42540:033855bc \u0026lt;\u0026lt; 通过输出的信息我们很容易知道DistinguishedName属性的值是“CN=Dummy,CN=Accounts,CN=useradm,DC=dummy,DC=net”。如果我们想查看更多内容，只需继续使用!dumpobject命令即可。\n!dumpstackobjects (!dso) 使用该命令我们可以查看到当前线程的堆栈引用的所有托管对象。打印信息如下：\n0:050\u0026gt; !dso OS Thread Id: 0x1e8c (50) ESP/REG Object Name 17a9e534 0741f860 System.RuntimeType 17a9e6b8 271fdfe0 System.DirectoryServices.Protocols.LdapConnection 17a9e6bc 27246f20 System.DirectoryServices.Protocols.SEC_WINNT_AUTH_IDENTITY_EX 17a9e740 271fdfe0 System.DirectoryServices.Protocols.LdapConnection 17a9e744 27246f20 System.DirectoryServices.Protocols.SEC_WINNT_AUTH_IDENTITY_EX 17a9e764 27246f20 System.DirectoryServices.Protocols.SEC_WINNT_AUTH_IDENTITY_EX 17a9e768 271fdfe0 System.DirectoryServices.Protocols.LdapConnection 17a9e780 271fdfe0 System.DirectoryServices.Protocols.LdapConnection 17a9e784 27246e38 System.DirectoryServices.Protocols.SearchRequest 17a9e794 271fdf14 System.DirectoryServices.Protocols.LdapDirectoryIdentifier 17a9e7a8 27246ef8 System.Collections.ArrayList 17a9e7bc 27246ef8 System.Collections.ArrayList 17a9e7c8 271fdfe0 System.DirectoryServices.Protocols.LdapConnection 17a9e8a4 27246e38 System.DirectoryServices.Protocols.SearchRequest 17a9e8d0 27246ed8 System.Object[] (System.Object[]) 17a9e8e0 073ff6b8 System.String cn 17a9e8e4 271fdfe0 System.DirectoryServices.Protocols.LdapConnection 17a9e8f4 27246d00 System.String CN=Dummy,CN=Accounts,CN=useradm,DC=Dummy,DC=net 17a9e8f8 271fdfe0 System.DirectoryServices.Protocols.LdapConnection 17a9e8fc 27246e38 System.DirectoryServices.Protocols.SearchRequest 17a9e910 03380310 System.String 17a9e914 27246e24 System.Object[] (System.String[]) 17a9e918 272399a8 System.String CN=OID-Dummy-ABC123,CN=Dummy,CN=Accounts,CN=useradm,DC=Dummy,DC=net 17a9e91c 27246ddc System.String (CN=OID-Dummy-ABC123) ...etc... 这个命令对于查找当前线程引用了那些对象很有用。假如你想查看某一对象，只需复制[Object]字段的地址，并使用 !dumpobject命令：\n0:050\u0026gt; !do 271fdfe0 Name: System.DirectoryServices.Protocols.LdapConnection MethodTable: 14a2040c EEClass: 149daf08 Size: 56(0x38) bytes (C:\\WINDOWS\\assembly\\GAC_MSIL\\System.DirectoryServices.Protocols\\2.0.0.0__b03f5f7f11d50a3a\\System.DirectoryServices.Protocols.dll) Fields: MT Field Offset Type VT Attr Value Name 14a2078c 40000c3 4 ...NetworkCredential 0 instance 00000000 directoryCredential 14a2144c 40000c4 8 ...ificateCollection 0 instance 271fe018 certificatesCollection 1202af88 40000c5 10 System.TimeSpan 1 instance 271fdff0 connectionTimeOut 1466fe50 40000c6 c ...rectoryIdentifier 0 instance 271fdf14 directoryIdentifier 14a2034c 4000236 24 System.Int32 0 instance 2 connectionAuthType 14a223a4 4000237 18 ...dapSessionOptions 0 instance 271fe2d8 options 0fb896d8 4000238 28 System.IntPtr 0 instance 564180944 ldapHandle 120261c8 4000239 2c System.Boolean 0 instance 0 disposed 120261c8 400023a 2d System.Boolean 0 instance 0 bounded 120261c8 400023b 2e System.Boolean 0 instance 0 needRebind 14a22084 400023e 1c ...pResponseCallback 0 instance 271fe03c fd 120261c8 4000243 2f System.Boolean 0 instance 0 setFQDNDone 120261c8 4000244 30 System.Boolean 0 instance 1 automaticBind 120261c8 4000245 31 System.Boolean 0 instance 1 needDispose 120261c8 4000246 32 System.Boolean 0 instance 1 connected 14a2267c 4000247 20 ...s.QUERYCLIENTCERT 0 instance 271fe394 clientCertificateRoutine 0fd314bc 400023c 20 ...ections.Hashtable 0 shared static handleTable \u0026gt;\u0026gt; Domain:Value 0019daf0:NotInit 11b42540:073fe504 \u0026lt; \u0026lt; 02c36ca0 400023d 24 System.Object 0 shared static objectLock \u0026gt;\u0026gt; Domain:Value 0019daf0:NotInit 11b42540:073fe53c \u0026lt; \u0026lt; 0fd314bc 400023f 28 ...ections.Hashtable 0 shared static asyncResultTable \u0026gt;\u0026gt; Domain:Value 0019daf0:NotInit 11b42540:073fe610 \u0026lt; \u0026lt; 14a21864 4000240 2c ...lResultsProcessor 0 shared static partialResultsProcessor \u0026gt;\u0026gt; Domain:Value 0019daf0:NotInit 11b42540:073fe678 \u0026lt; \u0026lt; 12305e94 4000241 30 ....ManualResetEvent 0 shared static waitHandle \u0026gt;\u0026gt; Domain:Value 0019daf0:NotInit 11b42540:073fe64c \u0026lt; \u0026lt; 14a21954 4000242 34 ...lResultsRetriever 0 shared static retriever \u0026gt;\u0026gt; Domain:Value 0019daf0:NotInit 11b42540:073fe6a8 \u0026lt; \u0026lt; !dumparray (!da) 你可能已经注意到有很多对象数组在堆栈中，在上面的列表中查找System.Object[]类型就能找到。如果你对对象数组使用 !dumpobject命令，你只能看到数组信息，而不能看到数组的内容信息，要看到数组内容信息，就需要使用!dumparray命令，或简称!da:\n0:050\u0026gt; !do 27239b98 Name: System.Object[] MethodTable: 02c3896c EEClass: 02c388ec Size: 24(0x18) bytes Array: Rank 1, Number of elements 2, Type CLASS Element Type: System.String Fields: None 0:050\u0026gt; !da 27239b98 Name: System.String[] MethodTable: 02c3896c EEClass: 02c388ec Size: 24(0x18) bytes Array: Rank 1, Number of elements 2, Type CLASS Element Methodtable: 02c39310 [0] 272399a8 [1] 27239a44 通过!dumparray命令我们能知道该数组对象是字符串数组，并给出了数组项的地址。再使用!dumpobject命令我们就能看到数组项的具体内容。\n!objsize 如果你查看上面打印的信息，可以看到对象的大小是24字节。从某方面来说，这是对的，24字节是System.Object[]数组对象本身大小，但并不包括数组内容的大小!要获得整个对象的大小，就要使用到 !objsize命令:\n0:050\u0026gt; !objsize 27239b98 sizeof(27239b98) = 348 ( 0x15c) bytes (System.Object[]) !objsize会遍历对象引用的所有子对象，并计算出总的大小。如上面数组对象和它的内容的总大小是348字节。 如果对象有引用很多子对象，那么!objsize会花费较多的时间计算出总大小。\n!dumpheap 这是另一个较频繁使用的命令。!dumpheap会打印出所有在托管堆中的对象信息。直接执行该命令会打印出大量的信息，所以一般使用时都至少带上一个参数。加上-stat参数后会输出总结后的信息，如下面是截取的是!dumpheap -stat命令输出的一部分:\n0:050\u0026gt; !dumpheap -stat ------------------------------ Heap 0 total 2754508 objects ------------------------------ Heap 1 total 2761329 objects ------------------------------ total 5515837 objects Statistics: MT Count TotalSize Class Name 16e0a6d8 1 12 System.Collections.Generic.ObjectEqualityComparer`1[[System.Data.ProviderBase.DbConnectionInternal, System.Data]] 16d9cd9c 1 12 System.Xml.Serialization.Configuration.DateTimeSerializationSection+DateTimeSerializationMode 16d9bf30 1 12 System.Diagnostics.OrdinalCaseInsensitiveComparer 16d9112c 1 12 System.Xml.Serialization.NameTable 16d7f664 1 12 System.Xml.Serialization.TempAssemblyCache 163ea85c 1 12 System.Data.Res 1501e4c4 1 12 System.Collections.Generic.ObjectEqualityComparer`1[[System.Web.UI.Control, System.Web]] 14efb138 1 12 System.Net.TimeoutValidator 14ef9964 1 12 System.Net.Cache.HttpRequestCacheLevel 14ef77a8 1 12 Microsoft.Win32.WinInetCache 14ef68e4 1 12 System.Net.WebRequest+WebProxyWrapper 14ef658c 1 12 System.Net.Configuration.ProxyElement+BypassOnLocalValues 14ef63d8 1 12 System.Net.Configuration.ProxyElement+AutoDetectValues 14ef5b68 1 12 System.Net.CaseInsensitiveAscii 14ef5610 1 12 System.Net.HeaderInfoTable 14ef4718 1 12 System.Net.HttpRequestCreator 14db6710 1 12 System.Web.Configuration.MachineKeyValidationConverter 14db3140 1 12 System.Collections.Generic.ObjectEqualityComparer`1[[System.Runtime.Serialization.MemberHolder, mscorlib]] 14b3f4d8 1 12 System.Web.UI.SupportsEventValidationAttribute ...etc... 14a276a8 19578 704808 System.DirectoryServices.Interop.AdsValueHelper 14a2ea24 9196 735680 System.Web.UI.WebControls.Label 14a2e51c 16862 741928 System.Web.UI.WebControls.Style 125778ec 48015 768240 System.Collections.Specialized.NameObjectCollectionBase+NameObjectEntry 120261c8 65842 790104 System.Boolean 14a2ee7c 9198 809424 System.Web.UI.WebControls.Table 14b311c4 9647 810348 System.Web.UI.WebControls.Image 13a2b7dc 34913 837912 System.Web.HttpServerVarsCollectionEntry 14b303a4 10605 848400 System.Web.UI.WebControls.HyperLink 14d8e3d4 77748 932976 Microsoft.Web.UI.WebControls.BaseChildNodeCollection+ActionType 14db90ac 81372 976464 System.Web.UI.WebControls.FontInfo 14b30694 28648 1031328 System.Web.UI.WebControls.TableRow+CellControlCollection 14d8fdbc 38912 1089536 Microsoft.Web.UI.WebControls.TreeNodeCollection 14b3d0bc 86592 1385472 System.Web.UI.Pair 1466c5c4 39305 1414980 System.Web.UI.ControlCollection 14d8e48c 77748 1865952 Microsoft.Web.UI.WebControls.BaseChildNodeCollection+Action 1545061c 38874 2176944 Microsoft.Web.UI.WebControls.TreeNode 14b30eec 52668 2317392 System.Web.UI.WebControls.TableItemStyle 14a2f804 28515 2395260 System.Web.UI.WebControls.TableRow 14a2be6c 40894 2453640 System.Web.UI.LiteralControl 0fd3da00 228792 2745504 System.Int32 14b3e3ac 244793 2937516 System.Web.UI.IndexedString 14a2de94 198580 3177280 System.Web.UI.StateBag 1466c454 80512 3542528 System.Web.UI.Control+OccasionalFields 12302c2c 205849 4116980 System.Collections.Specialized.HybridDictionary 14b30024 52934 4446456 System.Web.UI.WebControls.TableCell 12302f2c 178294 4992232 System.Collections.Specialized.ListDictionary 14a2e284 412762 6604192 System.Web.UI.StateItem 14d8ce64 117078 7024680 Microsoft.Web.UI.WebControls.CssCollection 0fd314bc 132065 7395640 System.Collections.Hashtable 1230319c 422580 8451600 System.Collections.Specialized.ListDictionary+DictionaryNode 1202a58c 380438 9130512 System.Collections.ArrayList 0fd32050 133000 22582944 System.Collections.Hashtable+bucket[] 02c3896c 649842 23275900 System.Object[] 0fd3c12c 3471 36385536 System.Byte[] 001fee20 338 65409920 Free 02c39310 683083 161821000 System.String Total 5515837 objects Fragmented blocks larger than 0.5 MB: Addr Size Followed by 2adf31cc 2.0MB 2aff85d8 System.String 2b006a2c 20.3MB 2c4530d8 System.Net.SocketAddress 输出信息按对象类型的总大小升序排序，你一般可以在列表的最下面找到string对象的大小，因为字符串在程序中一般是最常用的。 其他比较有用的参数是-type和-mt（MethodTable的意思）。使用它们你可以查看指定对象类型的详细信息，例如假如我们想查看System.Net.HttpRequestCreator类型的具体信息，可以复制上面列表中它的MT字段地址（14ef4718），然后使用 !dumpheap -mt命令：\n0:050\u0026gt; !dumpheap -mt 14ef4718 ------------------------------ Heap 0 Address MT Size 0342ccf8 14ef4718 12 total 1 objects ------------------------------ Heap 1 Address MT Size total 0 objects ------------------------------ total 1 objects Statistics: MT Count TotalSize Class Name 14ef4718 1 12 System.Net.HttpRequestCreator 上面列出了所有System.Net.HttpRequestCreator类型的对象的地址，假如我们想查看指定对象的信息，再使用!dumpobject命令就可以了。 !dumpheap -type可以根据字符串来匹配对应的对象类型。如我们输入命令“!dumpheap -type System.Web”，是指显示所有类名包含有“System.Web”字符串的对象信息。 其他参数-min和-max是接受表示对象大小的最大值和最小值（单位字节），命令会只列出大于指定值或小于指定值的对象信息。这两个参数对于查找滥用字符串问题很有帮助。\n实战训练 查明缓存使用的大小 为了知道在System.Web.Caching.Cache类型中有多少数据，我执行了“ !dumpheap -stat -type System.Web.Caching.Cache”命令。注意，我用了-stat参数，否则我会得到一个包含有System.Web.Caching.CacheKeys和System.Web.Caching.CacheEntrys对象的很长的列表。下面的执行结果：\n0:050\u0026gt; !dumpheap -type System.Web.Caching.Cache -stat ------------------------------ Heap 0 total 665 objects ------------------------------ Heap 1 total 1084 objects ------------------------------ total 1749 objects Statistics: MT Count TotalSize Class Name 123056f8 1 12 System.Web.Caching.CacheKeyComparer 1230494c 1 12 System.Web.Caching.Cache 1230500c 1 24 System.Web.Caching.CacheMultiple 1230514c 1 32 System.Web.Caching.CacheMemoryStats 123053b4 1 36 System.Web.Caching.CacheMemoryTotalMemoryPressure 123059bc 2 40 System.Web.Caching.CacheUsage 12304bdc 1 48 System.Web.Caching.CacheCommon 123054f4 1 52 System.Web.Caching.CacheMemoryPrivateBytesPressure 12305874 2 64 System.Web.Caching.CacheExpires 12304e64 2 200 System.Web.Caching.CacheSingle 1255b594 85 1360 System.Web.Caching.CacheDependency+DepFileInfo 123046c4 40 1440 System.Web.Caching.CacheDependency 123042ec 47 1504 System.Web.Caching.CacheItemRemovedCallback 123063fc 832 16640 System.Web.Caching.CacheKey 12306820 732 52704 System.Web.Caching.CacheEntry Total 1749 objects 很明显System.Web.Caching.Cache的方法列表地址（MethodTable）是1230494c，再使用!dumpheap命令我就能看到它的所有对象信息，如下：\n0:050\u0026gt; !dumpheap -mt 1230494c ------------------------------ Heap 0 Address MT Size 03392d20 1230494c 12 total 1 objects ------------------------------ Heap 1 Address MT Size total 0 objects ------------------------------ total 1 objects Statistics: MT Count TotalSize Class Name 1230494c 1 12 System.Web.Caching.Cache Total 1 objects 可以看到System.Web.Caching.Cache类型只有一个对象，地址是03392d20，再通过!objsize命令就能计算出它的大小。因为缓存对象很复杂，并包含有大量的子对象，要计算出总大小需要花些时间：\n0:050\u0026gt; !objsize 03392d20 sizeof(03392d20) = 266640828 ( 0xfe49dbc) bytes (System.Web.Caching.Cache) 所以缓存的总大小是 266 MB。\n缓存了什么东西？ 为了弄清缓存中保存了什么内容，我查看了System.Web.Caching.CacheEntry的对象信息。通过之前的信息可以知道System.Web.Caching.CacheEntry类型的方法列表(MethodTable)是12306820。执行!dumpheap命令取CacheEntry的所有对象信息：\n0:050\u0026gt; !dumpheap -mt 12306820 ------------------------------ Heap 0 Address MT Size 033950bc 12306820 72 033a20d8 12306820 72 033ac79c 12306820 72 033da21c 12306820 72 033f04c4 12306820 72 03428ec8 12306820 72 0344dab4 12306820 72 03815d00 12306820 72 038265d8 12306820 72 ....etc... 03af7010 12306820 72 03b291bc 12306820 72 03b2c674 12306820 72 03b6dca0 12306820 72 03b797dc 12306820 72 03b85318 12306820 72 03ba9150 12306820 72 03c258cc 12306820 72 03de43c8 12306820 72 03e160f8 12306820 72 total 382 objects ------------------------------ total 732 objects 要显示上面的信息，也可以使用“!dumpheap -type System.Web.Caching.CacheEntry”命令。 有了所有CacheEntry对象的地址信息，我随机拿了一个地址查看它的内容：\n0:050\u0026gt; !do 03b2c674 Name: System.Web.Caching.CacheEntry MethodTable: 12306820 EEClass: 122f6470 Size: 72(0x48) bytes (C:\\WINDOWS\\assembly\\GAC_32\\System.Web\\2.0.0.0__b03f5f7f11d50a3a\\System.Web.dll) Fields: MT Field Offset Type VT Attr Value Name 02c39310 4001327 4 System.String 0 instance 03b2c600 _key 0fb8f1f8 4001328 c System.Byte 0 instance 2 _bits 0fd3da00 4001329 8 System.Int32 0 instance -1314181915 _hashCode 02c36ca0 4001330 10 System.Object 0 instance 03b2c644 _value 120219d0 4001331 1c System.DateTime 1 instance 03b2c690 _utcCreated 120219d0 4001332 24 System.DateTime 1 instance 03b2c698 _utcExpires 1202af88 4001333 2c System.TimeSpan 1 instance 03b2c6a0 _slidingExpiration 0fb8f1f8 4001334 d System.Byte 0 instance 7 _expiresBucket 123062d8 4001335 34 ...g.ExpiresEntryRef 1 instance 03b2c6a8 _expiresEntryRef 0fb8f1f8 4001336 e System.Byte 0 instance 4294967295 _usageBucket 12306738 4001337 38 ...ing.UsageEntryRef 1 instance 03b2c6ac _usageEntryRef 120219d0 4001338 3c System.DateTime 1 instance 03b2c6b0 _utcLastUpdate 123046c4 4001339 14 ...g.CacheDependency 0 instance 00000000 _dependency 02c36ca0 400133a 18 System.Object 0 instance 033d8344 _onRemovedTargets 120219d0 400132d 1bc System.DateTime 1 shared static NoAbsoluteExpiration \u0026gt;\u0026gt; Domain:Value 0019daf0:NotInit 11b42540:03395104 \u0026lt; \u0026lt; 1202af88 400132e 1c0 System.TimeSpan 1 shared static NoSlidingExpiration \u0026gt;\u0026gt; Domain:Value 0019daf0:NotInit 11b42540:03395114 \u0026lt; \u0026lt; 1202af88 400132f 1c4 System.TimeSpan 1 shared static OneYear \u0026gt;\u0026gt; Domain:Value 0019daf0:NotInit 11b42540:03395124 \u0026lt; \u0026lt; 输出的是CacheEntry的属性信息，里面最重要的是_value属性。我复制它的地址（03b2c644），再用!dumpobject命令查看：\n0:000\u0026gt; !do 03e160c8 Name: System.Web.SessionState.InProcSessionState MethodTable: 14dbad5c EEClass: 14e43af8 Size: 48(0x30) bytes (C:\\WINDOWS\\assembly\\GAC_32\\System.Web\\2.0.0.0__b03f5f7f11d50a3a\\System.Web.dll) Fields: MT Field Offset Type VT Attr Value Name 1466c9d8 4001d89 4 ...ateItemCollection 0 instance 1a7f5438 _sessionItems 1292672c 4001d8a 8 ...ObjectsCollection 0 instance 00000000 _staticObjects 0fd3da00 4001d8b c System.Int32 0 instance 20 _timeout 120261c8 4001d8c 18 System.Boolean 0 instance 0 _locked 120219d0 4001d8d 1c System.DateTime 1 instance 03e160e4 _utcLockDate 0fd3da00 4001d8e 10 System.Int32 0 instance 1 _lockCookie 1202bf60 4001d8f 24 ...ReadWriteSpinLock 1 instance 03e160ec _spinLock 0fd3da00 4001d90 14 System.Int32 0 instance 0 _flags 可以看到缓存的是一个InProcSessionState对象。\n参考文章： Getting started with windbg - part I\nGetting started with windbg - part II\n","date":"2012-02-02T03:33:37Z","permalink":"https://blog.xenori.com/2012/02/windbg-useful-commands/","title":"WinDbg常用命令"},{"content":"原文：http://blogs.msdn.com/b/kaevans/archive/2011/04/11/intro-to-windbg-for-net-developers.aspx 翻译：bitxeno\n当你的代码发布为产品后，无论是在其他人的电脑中运行，还是部署到服务器中，你通常不再能访问到它的程序文件，也不能观察到代码的当前运行情况和运行环境。当你的代码在新的环境运行时，有很多因素会影响到程序的运行情况，如服务器系统打了更新补丁，网络策略改变，防火墙规则限制，磁盘权限配置等等。当代码运行不正常时，你可能只能靠代码中各处输出的日志来判断运行情况。但只靠输出日志，你有时还是不能判断故障出现的原因。\n在不浪费客户时间的同时做故障排除对你是个很大的挑战，因为不会有客户喜欢被一个搞技术的家伙不断问是点了那个按钮操作了哪些步骤导致程序出错的。boss也不会给你几天甚至几周的时间让你慢慢排除故障，你必须现在就知道到底发生了什么。\n理想情况下，你应该能看到堆栈跟踪，能查看到当前的变量值，能调试代码。事实证明你可以做到这点。。。而且不需要附加到客户环境中！\n下载WinDbg 下载Debugging Tools for Windows到你的本地开发机中，windbg是其中的一部分，如果你只需要windbg，在可以在“Common Utilities”中选择“Debugging Tools for Windows\u0026ldquo;进入安装。安装程序会根据你电脑的cpu类型安装对应的windbg，x86的电脑会安装x86版本，x64的cpu电脑就会安装x64版。如果你选择的是“Redistributable Packages“，就会为你下载全部三个版本（x86,x64,Itanium）。\nWinDbg默认会安装到c盘的“Program Files\\Debugging Tools for Windows”文件夹下，建议你把安装目录复制到“d:\\debug”，这样方便后面增加其他扩展组件。\n安装好后，目录下的windbg.exe就是windbg程序\n安装PssCor2\n****下一步是加载托管代码扩展组件PssCor2。默认时，WinDbg只能用于调试非托管代码程序 ，而加载.net使用的SOS.dll扩展组件后，WinDbg就能调试托管程序了。WinDbg调试.net程序的另一个选择是PssCor2，它是SOS.dll的超集，并提供了一些面对托管代码的额外功能，如查看托管线程，托管堆，CLR堆栈等等。\n下载PssCor2并解压到“d:\\debug”，以方便后面的调试使用。\n设定符号文件路径（Symbol Path）\n****当你使用Visual Studio编译程序时，是否有留意到在bin/Debug文件夹下会有.pdb后缀的文件？这些文件包含有dll程序集的调试符号，pdb文件并不包含有执行代码，只是使调试工具能把代码执行指令翻译为正确的可识别字符。微软提供了包含大量pdb文件的公共服务器，地址如下：\nhttp://msdl.microsoft.com/download/symbols\n在windbg中设定符号文件路径后，相关的pdb文件会自动从服务器下载下来并保存到本地。你首先需要指定一个pdb文件的保存路径，如“d:\\debug\\symbols”。\n打开windbg程序，选择“File-\u0026gt;Symbol File Path…“，把下面的内容复制进去保存。\nsrv*d:\\debug\\symbols*http://msdl.microsoft.com/download/symbols 创建测试程序\n我们先创建一个简单的命令行程序用于测试：\nusing System; namespace Microsoft.PFE.Samples { public class Program { static void Main() { Console.WriteLine(\u0026quot;Enter a message:\u0026quot;); string input = Console.ReadLine(); Data d = new Data { ID = 5, Message = input, CurrentDateTime = System.DateTime.Now }; Console.WriteLine(\u0026quot;You entered: \u0026quot; + d); } } public class Data { public int ID {get; set;} public string Message {get; set;} public DateTime CurrentDateTime {get; set;} public override string ToString() { Console.ReadLine(); return string.Format(\u0026quot;ID:{0} {1} at {2}\u0026quot;, ID, Message, CurrentDateTime.ToLongTimeString()); } } } 因为PssCor2只能处理.Net 3.5以下的程序，所以在编译前需要先把程序的环境改为.Net 3.5。假如是调试.NET 4.0的程序，可以下载PssCor4。编译运行程序，输入一个字符串，看程序是否运行正常。\n客户抱怨说不知道为什么程序需要按两次enter键。程序并不按我们的预期工作，我们必须找到具体的原因。作为一个简单的例子，我们能一眼看出代码中的ToString()方法中多了一次ReadLine()导致的，但我们这次试下用windbg找出问题所在。\n运行程序，输入一个字符串，按一次enter，当出现第二次输入提示时，不要动！我们处于捕捉问题的关键点，我们需要做一个dump文件。\n创建dump文件\n****在windows7和windows2008中，可以在任务管理器中直接创建dump文件。只需打开任务管理器，右键进程名并选择“Create Dump File”。\ndump文件创建成功后，我们会看到提示：\ndump文件是当前进程的内存快照，dump文件的大小会和进程使用的内存大小一样，为了减少体积，你可以使用压缩软件进行压缩。\n还有另外的工具可以创建dump文件，如Process Explorer from SysInternals，也只需要在任务管理中右键选择“Full Dump”。\nADPlus和DebugDiag也可以创建dump文件。ADPlus是windbg安装目录下的一个命令行程序，你可以用下面的命令创建一个dump文件：\nAdplus -quiet -hang -p 4332 -o d:\\debug 4332是进程id，任务管理器默认是不显示进程id的，要显示出来，需要在windows任务管理器选择“查看-\u0026gt;选择列”，勾选“PID（进程标识符）”。\n开始使用WinDbg\n****现在我们有了程序dump文件，打开windbg程序，选择菜单“File-\u0026gt;Open Crash Dump”，并选择刚创建的dump文件，你会看到一些信息：\nLoading Dump File [D:\\debug\\program6.dmp] User Mini Dump File: Only registers, stack and portions of memory are available Symbol search path is: srv*d:\\debug\\symbols*http://msdl.microsoft.com/download/symbols Executable search path is: Windows 7 Version 7600 MP (8 procs) Free x64 Product: WinNt, suite: SingleUserTS Machine Name: Debug session time: Sun Feb 6 10:43:57.000 2011 (GMT-6) System Uptime: not available Process Uptime: 0 days 1:05:48.000 ......................... ntdll!NtRequestWaitReplyPort+0xa: 00000000`76d2ff7a c3 ret 在上面的文字中，你可以看到dump文件的路径，符号文件的查找路径等信息。而程序最下方有个输入框，你可以在上面输入命令。\n显示模块\n让我们试下显示程序已加载了哪些模块。在窗口最下方的输入框中，输入“lm”命令。\n0:000\u0026gt; lm start end module name 00000000`00120000 00000000`00128000 program (deferred) 00000000`742b0000 00000000`74379000 msvcr80 (deferred) 00000000`76ac0000 00000000`76bba000 user32 (deferred) 00000000`76bc0000 00000000`76cdf000 kernel32 (pdb symbols) d:\\debug\\symbols\\kernel32.pdb\\D5E268B5DD1048A1BFB011C744DD3DFA2\\kernel32.pdb 00000000`76ce0000 00000000`76e8b000 ntdll (pdb symbols) d:\\debug\\symbols\\ntdll.pdb\\0F7FCF88442F4B0E9FB51DC4A754D9DE2\\ntdll.pdb 000007fe`f3fb0000 000007fe`f4134000 mscorjit (deferred) 000007fe`f5030000 000007fe`f5f0b000 mscorlib_ni (deferred) 000007fe`f7650000 000007fe`f7ffe000 mscorwks (deferred) 000007fe`f8010000 000007fe`f80a0000 mscoreei (deferred) 000007fe`f80a0000 000007fe`f810f000 mscoree (deferred) 000007fe`fcb70000 000007fe`fcb7f000 CRYPTBASE (deferred) 000007fe`fcc40000 000007fe`fcc4f000 profapi (deferred) 000007fe`fcf20000 000007fe`fcf8b000 KERNELBASE (deferred) 000007fe`fd0e0000 000007fe`fd2e2000 ole32 (deferred) 000007fe`fd4d0000 000007fe`fd59a000 usp10 (deferred) 000007fe`fd6f0000 000007fe`fe476000 shell32 (deferred) 000007fe`fe480000 000007fe`fe4ae000 imm32 (deferred) 000007fe`fe840000 000007fe`fe84e000 lpk (deferred) 000007fe`fe9d0000 000007fe`feaab000 advapi32 (deferred) 000007fe`feb50000 000007fe`fec7e000 rpcrt4 (deferred) 000007fe`fec80000 000007fe`fecf1000 shlwapi (deferred) 000007fe`fed00000 000007fe`fed67000 gdi32 (deferred) 000007fe`fee10000 000007fe`fef19000 msctf (deferred) 000007fe`fef20000 000007fe`fefbf000 msvcrt (deferred) 000007fe`fefd0000 000007fe`fefef000 sechost (deferred) 在上面的模块列表中，你需要关注的是mscorwks是否存在，PssCor2只能用于.NET 3.5的程序，假如是.NET 4.0程序，就看不到mscorwks模块。\n对于SharePoint开发人员，假如你正在调试程序特性如 receivers 和 event 处理为什么不触发，lm将是很好用的命令。通过上面的列表，你能知道有哪些模块没加载进来，可能是配置不正确导致的，这样能大大地减少你查找问题的范围。对于ASP.NET开发人员，会有助于查找HttpModule不触发的原因，可能是web.config配置不正确。\n加载PssCor2\n要把PssCor2扩展组件加载入windbg，需使用下面的命令：\n.load d:\\debug\\psscor2\\amd64\\psscor2.dll 我的电脑是64位的，所以我加载了AMD64 版本的PssCor2.dll。加载的PssCor2版本必须和dump文件进程所在服务器的架构相一致，假如你是调试x86程序的dump文件，你就必须加载x86版本的PssCor2.dll。 输入下面的命令，以确认PssCor2是否加载成功：\n!help 正确会输入下面的内容：\n0:000\u0026gt; .load d:\\debug\\psscor2\\amd64\\psscor2.dll 0:000\u0026gt; !help ------------------------------------------------------------------------------- PSSCOR is a debugger extension DLL designed to aid in the debugging of managed programs. Functions are listed by category, then roughly in order of importance. Shortcut names for popular functions are listed in parenthesis. Type \u0026quot;!help \u0026quot; for detailed info on that function. Object Inspection Examining code and stacks ----------------------------- ----------------------------- DumpObj (do) Threads DumpArray (da) CLRStack DumpStackObjects (dso) IP2MD DumpAllExceptions (dae) BPMD DumpHeap U DumpVC DumpStack GCRoot EEStack ObjSize GCInfo FinalizeQueue EHInfo PrintException (pe) COMState TraverseHeap DumpField (df) DumpDynamicAssemblies (dda) GCRef DumpColumnNames (dcn) DumpRequestQueues DumpUMService Examining CLR data structures Diagnostic Utilities ----------------------------- ----------------------------- DumpDomain VerifyHeap EEHeap DumpLog Name2EE FindAppDomain SyncBlk SaveModule DumpThreadConfig (dtc) SaveAllModules (sam) DumpMT GCHandles DumpClass GCHandleLeaks DumpMD VMMap Token2EE VMStat EEVersion ProcInfo DumpModule StopOnException (soe) ThreadPool MinidumpMode DumpHttpRuntime FindDebugTrue DumpIL FindDebugModules PrintDateTime Analysis DumpDataTables CLRUsage DumpAssembly CheckCurrentException (cce) RCWCleanupList CurrentExceptionName (cen) PrintIPAddress VerifyObj DumpHttpContext HeapStat ASPXPages GCWhere DumpASPNETCache (dac) ListNearObj (lno) DumpSig DumpMethodSig Other DumpRuntimeTypes ----------------------------- ConvertVTDateToDate (cvtdd) FAQ ConvertTicksToDate (ctd) DumpRequestTable DumpHistoryTable DumpBuckets GetWorkItems DumpXmlDocument (dxd) DumpCollection (dc) Examining the GC history ----------------------------- HistInit HistStats HistRoot HistObj HistObjFind HistClear mscordacwks.dll\n我喜欢在服务器中创建程序的dump文件，然后把dump文件转移到自己的windows7开发机上进行调试。假如服务器是Windows Server 2008 R2的操作系统，当我在本地开发机使用psscor2时，很容易遇到下面的错误：\nCLRDLL: CLR DLL load disabled Failed to load data access DLL, 0x80004005 Verify that 1) you have a recent build of the debugger (6.2.14 or newer) 2) the file mscordacwks.dll that matches your version of mscorwks.dll is in the version directory 3) or, if you are debugging a dump file, verify that the file mscordacwks___.dll is on your symbol path. 4) you are debugging on the same architecture as the dump file. For example, an IA64 dump file must be debugged on an IA64 machine. You can also run the debugger command .cordll to control the debugger's load of mscordacwks.dll. .cordll -ve -u -l will do a verbose reload. If that succeeds, the PSSCOR command should work on retry. If you are debugging a minidump, you need to make sure that your executable path is pointing to mscorwks.dll as well. 通过bing搜索发现一篇相关的博客文章how to work around the mscordacwks issue，文章指出需要把服务器的mscordacwks文件拷贝到windbg程序目录下。mscordacwks在我的Windows Server 2008 R2服务器上的版本是4952，所以我把服务器上的mscordacwks拷贝到windbg目录，并重命名为“mscordacwks_AMD64_AMD64_2.0.50727.4952.dll“。mscordacwks在服务器的路径是“”C:\\WINDOWS\\Microsoft.NET\\Framework\\v2.0.50727\\mscordacwks.dll”，假如你不知道正确的重命名规则，你可以输入下面的命令，输出会提示需要加载的mscordacwks命名。\n0:000\u0026gt; .cordll -ve -u -l CLR DLL status: No load attempts 0:000\u0026gt; !threads CLRDLL: C:\\WINDOWS\\Microsoft.NET\\Framework\\v2.0.50727\\mscordacwks.dll:2.0.50727.3053 f:0 doesn't match desired version 2.0.50727.3625 f:0 CLRDLL: Unable to find mscordacwks_AMD64_AMD64_2.0.50727.4952.dll by mscorwks search CLRDLL: Unable to find 'mscordacwks_AMD64_AMD64_2.0.50727.4952.dll' on the path CLRDLL: Unable to get version info for 'd:\\debug\\symbols\\mscorwks.dll\\4E154C985a9000\\mscordacwks_AMD64_AMD64_2.0.50727.4952.dll', Win32 error 0n87 CLRDLL: ERROR: Unable to load DLL mscordacwks_AMD64_AMD64_2.0.50727.4952.dll, Win32 error 0n87 Failed to load data access DLL, 0x80004005 Verify that 1) you have a recent build of the debugger (6.2.14 or newer) 2) the file mscordacwks.dll that matches your version of mscorwks.dll is in the version directory 3) or, if you are debugging a dump file, verify that the file mscordacwks___.dll is on your symbol path. 4) you are debugging on the same architecture as the dump file. For example, an IA64 dump file must be debugged on an IA64 machine. You can also run the debugger command .cordll to control the debugger's load of mscordacwks.dll. .cordll -ve -u -l will do a verbose reload. If that succeeds, the PSSCOR command should work on retry. If you are debugging a minidump, you need to make sure that your executable path is pointing to mscorwks.dll as well. 重命名后，再次输入上面的命令，会显示加载成功提示。\n0:000\u0026gt; .cordll -ve -u -l CLR DLL status: Loaded DLL mscordacwks_AMD64_AMD64_2.0.50727.4952.dll 检查CRL堆栈\n要查看CLR堆栈内容，输入下面命令：\n!clrstack 输出如下：\n0:000\u0026gt; !clrstack OS Thread Id: 0xa48 (0) *** WARNING: Unable to verify checksum for mscorlib.ni.dll Child-SP RetAddr Call Site 000000000012e910 000007fef5a910e9 DomainNeutralILStubClass.IL_STUB(Microsoft.Win32.SafeHandles.SafeFileHandle, Byte*, Int32, Int32 ByRef, IntPtr) 000000000012ea30 000007fef5a91202 System.IO.__ConsoleStream.ReadFileNative(Microsoft.Win32.SafeHandles.SafeFileHandle, Byte[], Int32, Int32, Int32, Int32 ByRef) 000000000012ea90 000007fef538065a System.IO.__ConsoleStream.Read(Byte[], Int32, Int32) 000000000012eaf0 000007fef53a28ca System.IO.StreamReader.ReadBuffer() 000000000012eb40 000007fef5a9435f System.IO.StreamReader.ReadLine() 000000000012eb90 000007ff0017015b System.IO.TextReader+SyncTextReader.ReadLine() 000000000012ebf0 000007fef791d502 Program.Main() 真棒！你现在可以看到堆栈的调用情况了。我们可以立即看到程序进入了Program.Main函数，调用Console.ReadLine并等待用户的输入。\n结论\n本篇文章只是简单介绍windbg的使用，假如你想全局的了解windbg，并如何使用windbg做故障排除，可以看下Tess Ferrandez的视频教程“Debugging .NET Applications with WinDbg“。\n扩展阅读：\nProcess Explorer from SysInternals\nPssCor2 Debugging Extension\nDownload the Debugging Tools for Windows\nSOS.dll (SOS Debugging Extension)\n“Failed to load data access DLL, 0x80004005” – OR – What is mscordacwks.dll?\nDebugDiag\nGetting started with windbg - part I\nGetting started with windbg - part II\n","date":"2012-02-01T08:28:43Z","permalink":"https://blog.xenori.com/2012/02/intro-to-windbg-for-dotnet-developers/","title":"面向.NET开发人员的WinDbg入门教程"},{"content":"HAProxy是linux平台上的负载均衡软件，有完善的服务器健康检测和会话(session)保持功能，性能高，支持tcp和http网络连接分发。\n问题起因 入公司一年，我发现在ASP.NET网站上部署更新时，经常会遇到下面这样的烦恼：\n假如更新到bin文件夹下的dll文件，会引起iis的应用程序池重启，从而导致更新这段时间内，用户访问网站会非常缓慢，甚至出现页面超时。\n部署更新时要小心翼翼，祈祷上帝没少拷了什么文件，假如更新后网站出错，就只能心跳加速地快速还原系统\n编辑经常提一些需求只是简单更改下页面文字，而为了不使这种简单的更改引起应用程序池重启，一般部署网站时都是采用copy方式发布，而网站也工作在debug模式下，而不是更优化速度更快的release模式\n上面几种情况都很影响用户体验，也让每次更新时肾上激素上升。 要解决上面的烦恼，需要满足下面几个条件：\n有至少两个以上的相同功能站点，当一个站点下线维护时，后续的请求能自动交给另一个站点处理\n有站点健康检测功能，可以一个个轮流地下线站点和上线站点，这过程中对用户的访问完全不受影响 应用HAProxy的负载均衡和服务器检测特性可以很好地解决上面的问题，最简单的负载均衡框架如下：\n192.168.1.2:8001 IP=192.168.1.1 192.168.1.2:8002 192.168.1.3 -------+-------------+-------+-----------+---- | | | _|_db +--+--+ +-+-+ +-+-+ (___) | LB | | A | | B | (___) +-----+ +---+ +---+ (___) haproxy 2 cheap web sites keepalived 192.168.1.1是一台linux服务器，运行着HAProxy。 192.168.1.2是一台windows服务器，iis上运行着两个相同的站点，端口分别设为8001/8002 192.168.1.3是数据库服务器\nHAProxy部署测试 安装HAProxy 在ubuntu中安装HAProxy很简单，执行下面的命令就能自动下载安装：\nsudo apt-get install haproxy 假如ubuntu服务器上的不是最新版，你想安装最新版，可以到官网下载最新的tar压缩包，解压后进入该目录，执行下面的命令：\nmake install 配置HAProxy 创建配置文件haproxy.cfg\nmkdir /etc/haproxy vim /etc/haproxy/haproxy.cfg HAProxy提供了两种零停机维护方案，一种是定时检测指定文件的请求是否成功，不成功超过指定次数后，可认为服务器已停机，新进入的连接会自动分发到其他机器，另一种是使用备份服务器，下面只介绍最简单的第一种。 HAProxy实现服务器检测和负载均衡的简单配置如下：\n# this config needs haproxy-1.1.28 or haproxy-1.2.1 global maxconn 4096 uid 99 gid 99 daemon defaults mode http timeout connect 5000ms timeout client 50000ms timeout server 50000ms option redispatch listen http-in bind *:80 balance roundrobin option httpchk HEAD /deploy.txt HTTP/1.0 server server1 192.168.1.2:8001 check inter 2000 rise 2 fall 2 server server2 192.168.1.2:8002 check inter 2000 rise 2 fall 2 下面说下主要的几个配置项： option redispatch：当之前连接的服务器宕机后，自动把连接分发到其他服务器 bind：监听指定的端口 balance roundrobin：以轮询的方式分发连接 option httpchk HEAD /deploy.txt HTTP/1.0：通过请求/deploy.txt文件来确定服务器健康情况 server server1 192.168.1.2:8001：指定分发的站点，server1可以是任意名称，在写log时使用 check inter 2000：表示服务器检测的间隔时间，2000指2秒，单位是毫秒 rise 2：表示服务器检测请求成功2次后，可认为站点已恢复，连接可以重新分发给它 fall 2：表示服务检测请求失败2次后，可认为站点已宕机，之后不会再分发连接给它\n详细的配置说明可以看HAProxy配置文档\n运行HAProxy 执行下面的命令检查配置是否正确：\nhaproxy -f /etc/haproxy/haproxy.cfg -c 运行haproxy：\nhaproxy -f /etc/haproxy/haproxy.cfg 创建测试站点 在服务器192.168.1.2中，创建站点server1，server2，端口分别是8001，8002。 server1中创建default.htm网页，并输出内容： server2中创建default.htm网页，并输出内容： 在server1和server2根目录都创建一个空白的deploy.txt文本文件，以便haproxy用来检测服务器健康情况.\n测试 在浏览器中访问linux服务器的http://192.168.1.1地址，就能看到server1和server2的站点内容，每次刷新网页会轮流显示server1和server2的default.htm内容，因为现在是以轮询方式分发请求连接的。 尝试把server1中的deploy.txt文件重命名为deploy1.txt，重命名后因为haproxy检测deploy.txt时返回404，haproxy会认为是服务器有问题，当经过4秒后，重新刷新网页，可以看到网页只显示server2的网页内容。 重新把server1的deploy1.txt改回deploy.txt，静待4秒后再刷新网页，可以看到又能显示server1的网页内容了。\n参考资料： Zero-Downtime Restarts with HAProxy HAProxy Architecture Guide\n","date":"2012-01-21T08:04:49Z","permalink":"https://blog.xenori.com/2012/01/zero-downtime-with-haproxy/","title":"利用HAProxy实现零停机更新维护"},{"content":"1、安装JAVA SDK\n到官网（http://www.oracle.com/technetwork/java/javase/downloads/index.html ）下载最新的javase sdk，推荐安装1.6版。安装完成后，在windows环境变量中添加[JAVA_HOME]，并把路径指向java sdk的安装根目录。\n2、安装Scala\n从scala官网（http://www.scala-lang.org/downloads ）下载windows版的压缩包，推荐2.8.1 final版，直接解压到相应目录中，假设为c:\\scala-2.8.1.final\\，再添加下面两个环境变量：\n新增环境变量SCALA_HOME，并设为c:\\scala-2.8.1.final\n在已有环境变量Path中，追加值c:\\scala-2.8.1.final\\bin\n通过win-\u0026gt;run-cmd打开命令行，输入scala，能输出版本信息证明已安装成功\n3、安装Eclipse\n到Eclipse官网（http://www.eclipse.org/downloads/）下载，直接解压就能使用，推荐下载Eclipse Classic/Eclipse For Java。\n4、安装Android SDK\n到android开发社区(http://developer.android.com/sdk/index.html)下载安装。安装后进入开始 \u0026gt; 所有程序 \u0026gt; Android SDK \u0026gt; SDK Manager程序，软件会提示一些可安装的更新，大家可以根据需要选择安装，建议安装下面图中所示的：\n之后是漫长的等待\u0026hellip;\n装ADT Plugin for Eclipse 等待android sdk安装好后，打开Eclipse，进入菜单Help \u0026gt; Install New Software\u0026hellip;.，点击**Add，**添加链接\nhttps://dl-ssl.google.com/android/eclipse/ 勾选所有项目，然后点击Next安装。\n安装完成并重启Eclipse后，进入菜单Window \u0026gt; Preferences \u0026gt; Android，点击Browser，把路径指向android sdk的安装目录，然后点击Apply。\n6、安装Scala IDE Plugin 打开Eclipse，进入菜单Help \u0026gt; Install New Software\u0026hellip;.，点击**Add，**添加链接\nhttp://download.scala-ide.org/releases-28/2.0.0-beta 勾选安装下面两项：\nJDT weaving For scala\n**Scala IDE for Eclipse ** 7、安装Treesaker ** 打开Eclipse**，进入菜单Help \u0026gt; Install New Software\u0026hellip;.，点击**Add，**添加链接\nhttp://treeshaker.googlecode.com/svn/trunk/update_site/ 勾选treeshaker,点击Next安装。\ntreeshaker是一个开源的辅助插件，详细可以访问项目地址：http://code.google.com/p/treeshaker/\n8、简单的helloworld\nEclipse中打开File \u0026gt; New \u0026gt; Project \u0026gt; Android Project创建一个新的android工程项目：\n按下面的步骤把java的项目转为scala的项目：\n1、把src文件夹重命名为_src（右键src \u0026gt; Refactor \u0026gt; Rename) 2、右键HelloWorld项目 \u0026gt; Configure \u0026gt; Add Scala Nature 3、右键HelloWorld项目 \u0026gt; Add/Remove Treeshaker 4、打开菜单Project \u0026gt; Properties \u0026gt; Builders，确保builder的顺序和如下一样：\nAndroid Resource Manager\nAndroid Pre Compiler\nScala Builder\nTreeshaker\nAndroid Package Builder\n5、打开res\\layout\\main.xml，把下面的内容替换中的内容：\n\u0026lt;TextView android:layout_width=\u0026quot;fill_parent\u0026quot; android:layout_height=\u0026quot;wrap_content\u0026quot; android:text=\u0026quot;@string/hello\u0026quot; android:id=\u0026quot;@+id/text\u0026quot; /\u0026gt; \u0026lt;Button android:id=\u0026quot;@+id/button\u0026quot; android:layout_width=\u0026quot;wrap_content\u0026quot; android:layout_height=\u0026quot;wrap_content\u0026quot; android:text=\u0026quot;Click me\u0026quot; /\u0026gt; 5、删除_src下的源文件HelloWorldActivity.java 6、创建新的scala代码文件，右键包com.test，选择New \u0026gt; Other \u0026gt; Scala Class Name设为HelloWorldActivty，Superclass设为android.app.Activity 7、修改HelloWorldActivity.scala文件： 增加导入：\nimport android.os.Bundle import android.view.View import android.widget.TextView import android.widget.Button import R._ HelloWorldAcitvity类中增加代码：\noverride def onCreate(savedInstanceState: Bundle) { super.onCreate(savedInstanceState) setContentView(R.layout.main) val textView = findViewById(R.id.text).asInstanceOf[TextView] val button = findViewById(R.id.button).asInstanceOf[Button] button.setOnClickListener((v: View) =\u0026gt; textView.setText(\u0026quot;Hello Scala\u0026quot;)) } implicit def func2OnClickListener(func : (View) =\u0026gt; Unit) : View.OnClickListener = { return new View.OnClickListener() { override def onClick(v: View) = func(v) } } 8、通过菜单Run \u0026gt; Run，应该能正常编译并在android模拟器中运行了\n扩展阅读：\nCreateNewScalaProject\nScalaでAndroidアプリ開発 Building Android Apps with Scala - IntelliJ Exploring Android With Scala\n","date":"2012-01-21T07:06:00Z","permalink":"https://blog.xenori.com/2012/01/use-eclipse-scala-develop-android/","title":"利用Eclipse+Scala搭建android开发环境"},{"content":"有时，我们安装的windows服务可能是个框架，在同一服务器上可能服务于不同的系统，为了使服务名称不冲突，需要把服务名称更改为可配置。 因为ServiceInstaller能直接设置安装服务的名称和描述，所以很容易就能写出下面的代码：\nserviceInstaller.ServiceName = ConfigurationManager.AppSetting[\u0026quot;ServiceName\u0026quot;]; serviceInstaller.Description = ConfigurationManager.AppSetting[\u0026quot;ServiceDescription\u0026quot;]; 编译执行安装，可惜抛出了异常，安装失败了。 失败的原因是，执行安装服务的程序是InstallUtil.exe，安装阶段不会自动加载服务的app.config配置文件，只会加载全局的machine.config，需改为手动加载app.config并读取。 确定解决思路后，我写出了下面的代码：\nvar targetDirectory = AppDomain.CurrentDomain.BaseDirectory; var configPath = Path.Combine(targetDirectory, \u0026ldquo;Service.exe\u0026rdquo;); var config = ConfigurationManager.OpenExeConfiguration(configPath); serviceInstaller.ServiceName = config.AppSettings.Settings[\u0026ldquo;ServiceName\u0026rdquo;].Value; serviceInstaller.Description = config.AppSettings.Settings[\u0026ldquo;ServiceDescription\u0026rdquo;].Value;\n再次编译运行，发现本机上安装成功了：），整个程序打包交给另一个同事在服务器上安装，发现安装过程又出错了。。。 过去看了一下，发现错误的原因是，本机安装时，InstallUtil程序我是放在和服务同一目录，而服务器上的InstallUtil是和服务在不同目录。看来AppDomain.CurrentDomain.BaseDirectory获取到的是InstallUtil的应用程序域目录路径，而不是服务的。 之后使用反射来解决了这个问题，代码如下：\nvar path = System.Reflection.Assembly.GetExecutingAssembly().Location; var targetDirectory = System.IO.Path.GetDirectoryName(path); var configPath = Path.Combine(targetDirectory, \u0026quot;Service.exe\u0026quot;); var config = ConfigurationManager.OpenExeConfiguration(configPath); serviceInstaller.ServiceName = config.AppSettings.Settings[\u0026quot;ServiceName\u0026quot;].Value; serviceInstaller.Description = config.AppSettings.Settings[\u0026quot;ServiceDescription\u0026quot;].Value; ","date":"2012-01-12T07:42:04Z","permalink":"https://blog.xenori.com/2012/01/config-windows-services-install-name/","title":"使windows服务安装名称可配置"},{"content":"现在系统中常用的获取客户端真实ip的代码如下：\n// 获取IP地址 protected string GetIPAddress() { string result = \u0026quot;\u0026quot;; try { //透过代理取客户端ip result = HttpContext.Current.Request.ServerVariables[\u0026quot;HTTP_X_FORWARDED_FOR\u0026quot;] ?? \u0026quot;\u0026quot;; if (result == \u0026quot;\u0026quot;) { //连接主机ip result = HttpContext.Current.Request.ServerVariables[\u0026quot;REMOTE_ADDR\u0026quot;] ?? \u0026quot;\u0026quot;; } if (result == \u0026quot;\u0026quot;) { result = HttpContext.Current.Request.UserHostAddress; } } catch (Exception ex) { } return result; } 这段代码有两个问题： 1、根据这篇文章说明，当请求经常多个代理时，HTTP_X_FORWARDED_FOR可能会附加上多个服务器ip，格式如下：\nX-Forwarded-For: client1, proxy1, proxy2, \u0026hellip;\n正确的客户端ip应该只是第一个ip地址\n2、当用户手机是用CMWAP访问网站时，上面代码返回的是10.xxx的私有网络ip，而真实的服务器ip是在REMOTE_ADDR中，如下图所示： 所以对于获取来的ip，需要做是否私有网络ip的判断。所有私有网络的ip段如下：\nprivate static readonly long[,] privateIpRange = { //私有网络ip段,长整形表示 {0,50331647}, //{\u0026quot;0.0.0.0\u0026quot;,\u0026quot;2.255.255.255\u0026quot;}, {167772160,184549375}, //{\u0026quot;10.0.0.0\u0026quot;,\u0026quot;10.255.255.255\u0026quot;}, {2130706432,2147483647}, //{\u0026quot;127.0.0.0\u0026quot;,\u0026quot;127.255.255.255\u0026quot;}, {2851995648,2852061183}, //{\u0026quot;169.254.0.0\u0026quot;,\u0026quot;169.254.255.255\u0026quot;}, {2886729728,2887778303}, //{\u0026quot;172.16.0.0\u0026quot;,\u0026quot;172.31.255.255\u0026quot;}, {3221225984,3221226239}, //{\u0026quot;192.0.2.0\u0026quot;,\u0026quot;192.0.2.255\u0026quot;}, {3232235520,3232301055}, //{\u0026quot;192.168.0.0\u0026quot;,\u0026quot;192.168.255.255\u0026quot;}, {4294967040,4294967295}}; //{\u0026quot;255.255.255.0\u0026quot;,\u0026quot;255.255.255.255\u0026quot;} ","date":"2012-01-09T07:39:49Z","permalink":"https://blog.xenori.com/2012/01/get-client-ip/","title":"获取客户端的真实ip代码改进"},{"content":"新浪有开放ip查询的接口（http://int.dpool.sina.com.cn/iplookup/iplookup.php?format=json\u0026amp;ip=123.124.2.85），通过不断查询就能抓取到ip信息。不过要遍历所有的ip地址不现实，数据存储和查询都是问题，一般我们面对的是中国的用户，只需要遍历抓取下中国范围的ip信息就行，而且ip地址最后一位的256个ip一般分配到同一地区，所以最后一位只需遍历.0的ip就可以了。 目前ip4地址已经分配完，中国的ip段可以在以下网址找到： https://www.countryipblocks.net/e_country_data/CN_range.txt 首先需要处理，把上面的ip段转换为具体的ip地址：\nprivate static List HandleIpRange() { var list = new List(); var lines = File.ReadAllLines(\u0026ldquo;CN_range.txt\u0026rdquo;); var pattern = @\u0026quot;(\\d{1,3}.\\d{1,3}.\\d{1,3}.\\d{1,3})\\s-\\s(\\d{1,3}.\\d{1,3}.\\d{1,3}.\\d{1,3})\u0026quot;; foreach (var line in lines) { var match = Regex.Match(line, pattern, RegexOptions.IgnoreCase); if (match.Success) { var begin = match.Groups[1].Value; var end = match.Groups[2].Value;\nvar beginInt = Ip3ToInt(begin); var endInt = Ip3ToInt(end); while (beginInt \u0026lt;= endInt) { list.Add(IntToIp3(beginInt)); beginInt += 1; } } } return list; } private static int Ip3ToInt(string ip4) { var arr = ip4.Split('.'); var p0 = int.Parse(arr[0]); var p1 = int.Parse(arr[1]); var p2 = int.Parse(arr[2]); return (p0 \u0026lt;\u0026lt; 16) | (p1 \u0026lt;\u0026lt; 8) | p2; } private static string IntToIp3(int s) { var p0 = s \u0026gt;\u0026gt; 16 \u0026amp; 0xFF; var p1 = s \u0026gt;\u0026gt; 8 \u0026amp; 0xFF; var p2 = s \u0026amp; 0xFF; return string.Format(\u0026quot;{0}.{1}.{2}.0\u0026quot;, p0, p1, p2); } 剩下只需用多线程请求新浪接口，把结果保存到数据库就可以了。\n数据修正： 从新浪接口查询回来的数据，有一部分国家和省市都是空的，还有一部分国家是美国等，这部分数据需要修正下。数据修正可以查询ip138网站，它的数据来源是APNIC，比较新，请求地址如下（http://www.ip138.com/ips8.asp?action=2\u0026amp;ip=223.72.166.0）。把请求回来的内容用正则解析并update到数据库就可以了。\n进一步减少数据大小： 新浪接口返回的内容都会带有start和end的ip段，表示ip段中的ip都是属于同一地区。可以把start和end的ip转换为int值，再把int表示的ip段和地区信息保存到另一张表中。查询用户ip所属时，只需把用户ip也转换为int值，再找出int值所在的ip段对应的地区就可以了。\n","date":"2012-01-09T07:23:24Z","permalink":"https://blog.xenori.com/2012/01/crawl-sina-ip-data/","title":"通过新浪接口抓取ip库"},{"content":"1、为什么需要使用线程池(Thread Pool）\n**减少线程间上下文切换。**线程执行一定的时间片后，系统会自动把cpu切换给另一个线程使用，这时还需要保存当前的线程上下文状态，并加载新线程的上下文状态。当程序中有大量的线程时，每个线程分得的时间片会越来越少，可能会出现线程未处理多少操作，就需要切换到另一线程，这样频繁的线程间上下文切换会花费大量的cpu时间。\n**减少内存占用。**系统每创建一条物理线程，需要大概花费1MB的内存空间，许多程序喜欢先创建多条物理线程，并周期轮询来处理各自的任务，这样既消耗了线程上下文切换的时间，还浪费了内存。这些任务可能只需要一条线程就能满足要求。假如某一任务需要执行较长的周期，线程池还可以自动增加线程，并在空闲时，销毁线程，释放占用的内存。\n2、为什么不使用.Net默认的线程池\n.Net默认的线程池(ThreadPool)是一个静态类，所以是没办法自己创建一个新的程序池的。默认的线程池与应用程序域(AppDomain)挂钩，一个AppDomain只有一个线程池。假如在线程池中执行了一个周期较长的任务，一直占用着其中一个线程，可能就会影响到应用程序域中的其他程序的性能。例如，假如在Asp.Net的线程池中执行一个周期较长的任务，就会影响请求的并发处理能力（线程池默认有个最大线程数）。 3、SmartThreadPool特性和优点 SmartThreadPool特性如下：\n池中的线程数量会根据负载自动增减\n任务异步执行后可以返回值\n处于任务队列中未执行的任务可以取消\n回调函数可以等待多个任务都执行完成后再触发\n任务可以有优先级(priority)\n任务可以分组\n支持泛型Action 和 Func\n有性能监测机制\n4、使用示例 最简单的使用方法：\n// 创建一个线程池 SmartThreadPool smartThreadPool = new SmartThreadPool(); // 执行任务 smartThreadPool.QueueWorkItem(() =\u0026gt; { Console.WriteLine(\u0026quot;Hello World!\u0026quot;); }); 带返回值的任务：\n// 创建一个线程池 SmartThreadPool smartThreadPool = new SmartThreadPool(); // 执行任务 var result = smartThreadPool.QueueWorkItem(() =\u0026gt; { var sum = 0; for (var i = 0; i \u0026lt; 10; i++) sum += i; return sum; }); // 输出计算结果 Console.WriteLine(result.Result); 等待多个任务执行完成：\n// 创建一个线程池 SmartThreadPool smartThreadPool = new SmartThreadPool(); // 执行任务 var result1 = smartThreadPool.QueueWorkItem(() =\u0026gt; { //模拟计算较长时间 Thread.Sleep(5000); return 3; }); var result2 = smartThreadPool.QueueWorkItem(() =\u0026gt; { //模拟计算较长时间 Thread.Sleep(3000); return 5; }); bool success = SmartThreadPool.WaitAll( new IWorkItemResult[] { result1, result2 }); if (success) { // 输出结果 Console.WriteLine(result1.Result); Console.WriteLine(result2.Result); } 5、结论 使用SmartThreadPool可以简单就实现支持多线程的程序，由线程池来管理线程，可以减少死锁的出现。SmartThreadPool还支持简单的生产者-消费者模式，当不需要对任务进行持久化时，还是很好用的。\n6、扩展阅读\nhttp://www.codeproject.com/KB/threads/smartthreadpool.aspx http://smartthreadpool.codeplex.com/ http://www.albahari.com/threading/\n","date":"2012-01-09T07:11:38Z","permalink":"https://blog.xenori.com/2012/01/smartthreadpool/","title":"开源线程池组件SmartThreadPool"},{"content":"PetaPoco是一个简单轻巧的orm开源类库，全部功能只有一个文件，可以很方便集成到项目中。代替SqlHelper辅助类的不二选择。。。\n主要功能包括： - 映射实体类，支持enum，Nullable等类型，可同时映射多个实例。 - 支持分页 - 以@0等占位符代替SqlParameter，传参更方便 - 带有sql字符串构造器，构造条件查询sql非常方便 - update支持指定字段更新 - 支持T4模板 使用示例： 使用前需要先new一个数据库实例：\nvar db = new PetaPoco.Database(\u0026quot;ConnectionName\u0026quot;); 可以放心地把db实例设为static，因为实例中没有SqlConnection的引用，连接每次执行完后，会自动关闭。 发现有人反映在web上使用static的db实例还是会有问题，具体可看链接(Link1)，StackOverflow中推荐web中每个请求使用一个单独的db实例(Link2). 1、取一条记录\nvar a = db.SingleOrDefault\u0026lt;article\u0026gt;(\u0026quot;SELECT * FROM articles WHERE article_id=@0\u0026quot;, 123));\u0026lt;/article\u0026gt; 2、分页\n// 分页实质在内部是用Row_Number()重写了sql，支持join var result=db.Page\u0026lt;article\u0026gt;(1, 20, \u0026quot;SELECT * FROM articles WHERE category=@0 ORDER BY date_created DESC\u0026quot;, \u0026quot;coolstuff\u0026quot;);\u0026lt;/article\u0026gt; 上面的分页sql，会被改写为sql：\nSELECT * FROM ( SELECT ROW_NUMBER() OVER (ORDER BY date_created DESC) peta_rn, * FROM articles WHERE category=@0 ) peta_paged WHERE peta_rn\u0026gt;@1 AND peta_rn 3、部分更新\ndb.Update(\u0026quot;articles\u0026quot;, \u0026quot;article_id\u0026quot;, new { title=\u0026quot;New title\u0026quot; }, 123); 4、sql条件构造\nvar sql = PetaPoco.Sql.Builder .Append(\u0026quot;SELECT * FROM articles\u0026quot;) .Append(\u0026quot;WHERE article_id=@0\u0026quot;, id) .Append(\u0026quot;WHERE date_created\u0026gt;=@0\u0026quot;, start_date.Value) .Append(\u0026quot;WHERE date_created 5、直接执行sql\ndb.Execute(\u0026quot;DELETE FROM articles WHERE draft\u0026lt;\u0026gt;0\u0026quot;); 6、调用存储过程\n//调用存储过程 db.Execute(\u0026quot;exec procSomeHandler @0, @1\u0026quot;, 3, \u0026quot;2011-10-01\u0026quot;); //调用带输出(OUTPUT)参数的存储过程, 写的sql语句，@0参数后的“output”是关键 var param = new SqlParameter() { Direction = ParameterDirection.Output, SqlDbType = SqlDbType.Int }; db.Execute(\u0026quot;exec procSomeHandler @0 OUTPUT\u0026quot;, param); 7、代替返回值DataTable 有时，我们并不想每条执行的sql都需要创建对应的实体类，这样会导致项目中存在过多的实体类，有方法能做到DataTable这样灵活就最好了。在.net4.0中，PetaPoco可以返回dynamic类型，可以很好地解决这个问题，而在.net3.5中就没办法，不过可以通过修改PetaPoco代码，实现使用Dictionary类型来代替dynamic动态类型的功能。改动代码如下：https://github.com/bitxeno/PetaPoco/commit/e07746c06977f09ef8e7a0f81b718e520b4513ed\nvar list = db.Fetch\u0026gt;(\u0026quot;select article_id,date_created from articles\u0026quot;); 使用petapoco时有点需要注意，就是当数据库字段数据类型是varchar等非unicode字符类型时，petapoco传参需要把string转换为AnsiString类型，否则会有性能问题。\nAnsi String Support DBA guru Rob Sullivan yesterday pointed out that SQL Server has pretty severe performance overhead if you try to query an index with varchar column using a unicode string parameter. To fix this the parameter needs to be bound as DbType.AnsiString. To facilitate this you can now wrap such string parameters in a new AnsiString class: var a = db.SingleOrDefault\u0026lt;article\u0026gt;(\u0026quot;WHERE title=@0\u0026quot;, new PetaPoco.AnsiString(\u0026quot;blah\u0026quot;));\u0026lt;/article\u0026gt; 参考资料： http://code.google.com/p/dapper-dot-net/ http://www.toptensoftware.com/petapoco/\n","date":"2012-01-09T05:11:52Z","permalink":"https://blog.xenori.com/2012/01/petapoco/","title":"小巧方便的ORM类库——PetaPoco"},{"content":"虽然自己很懒，不过还是总结下2011年做过的事，可能以后回顾时会有另一番收获。 今年因为转入了互联网行业，所以在技术上学到了很多新东西，开发时也更关注性能优化和并发，对单元测试也慢慢熟悉起来。今年稍有研究的技术有这些：\n负载均衡faiover。为了使部署更新到生产环境时，减少对用户的影响，特意研究了下当前热门的解决方案。当前流行的负载均衡软件有nginx和HAProxy，可惜到最后还是没用到生产环境中，现在还是不明白当我部署一台时，新的连接是否会自动路由到另一个web服务器。 ETL大数据量转移。最后使用SSIS完成把MySQL数据转移到SqlServer。 多线程开发。最后找到了个SmartThreadPool的线程池组件，很好用。 Redis和Memcached学习 数据库性能优化。对数据库索引更深入的理解，今年是多得这个网站：http://use-the-index-luke.com/，极力推荐看网站上的ebook 消息队列。是为了优化一个物品交易系统而学习的，觉得不错的有ZeroMq和Redis。 今年虽然接触了很多新技术，感觉很充实，可惜的是，还是没做出一个令自己满意的产品。每次看自己做的项目都像一个半成品，实在不好意思向朋友推荐，下一年的目标还是希望能做出一个好产品。\n今年因为有了GR和微博，对行业的信息更了解了，也从别人的分享中了解很多新技术。而购买了iPad后，看书很有动力，今年看了很多英文版的书，如《CLR Via C#》、《Pro Asp.Net MVC 3》、《Programming the Mobile Web》等，年度最喜爱的书是《黑客与画家》和《大家看的设计书》(^o^)/。\n今年感情生活还是一片空白，不过心情倒是轻松很多。过年过节看到别人一对对还有各种得意的小屁孩，心里是有点羡慕，不过已经学会很谈然了。现在对感情方面反而不强烈，更多的精力还是花在工作和攒更多钱上($$)。\n今年差不多不上q了，游戏也因为兴趣越来越少，也很少碰。买来的ps3就通了TOX，其他时间吃灰。。。平时大多数时间都在刷微博，当然，知乎也很好，能学到很多有趣的知识。\n又新的一年，即将迈进30大关。。。前途仍然迷茫得不知所措。 愿我的家人永远健康幸福，我最大的愿望。\n","date":"2012-01-04T13:59:21Z","permalink":"https://blog.xenori.com/2012/01/summarize2011/","title":"2011总结"},{"content":"腾讯：http://ip.qq.com/cgi-bin/searchip?searchip1=121.236.225.37 现在只能通过解析页面内容到取得\n新浪：http://int.dpool.sina.com.cn/iplookup/iplookup.php?format=json\u0026amp;ip=123.124.2.85\n网易： http://www.youdao.com/smartresult-xml/search.s?type=ip\u0026amp;q=123.124.2.85\nip地址在各个国家的分配情况表： http://ftp.apnic.net/apnic/stats/apnic/delegated-apnic-latest http://www.countryipblocks.net/country-blocks/ip-range-format/\n","date":"2011-12-25T06:09:12Z","permalink":"https://blog.xenori.com/2011/12/ip-lookup/","title":"门户网站的ip查询接口"},{"content":"GoAgent是个很强的Appspot代理程序，看youtube毫无压力=w=，chrome+SwitchySharp也很好用，下面是个简单的部署步骤： 1、到http://code.google.com/p/goagent/下载最新版的GoAgent 2、首选dns要设为8.8.8.8 3、到http://code.google.com/p/smarthosts/下载最新程序更新下hosts 4、按GoAgent部署教程上传程序到Appspot 5、把SwitchSharp的代理设为127.0.0.1:8087，并把在代规则指向：http://autoproxy-gfwlist.googlecode.com/svn/trunk/gfwlist.txt 6、have fun!\n更详细教程： http://maolihui.com/goagent-detailed-version-of-the-tutorial.html\n","date":"2011-12-10T09:19:25Z","permalink":"https://blog.xenori.com/2011/12/open-the-doo/","title":"GoAgent翻了个墙"},{"content":"这是内部技术分享的ppt\n","date":"2011-12-07T15:51:09Z","permalink":"https://blog.xenori.com/2011/12/lucene-knowledge/","title":"Lucene实践"},{"content":"在我的xp3上安装S60_3rd_FP2_SDK_v1.1版本模块器，在运行时会出现闪退的问题（在xp2上好像没这问题)，解决方法如下：\n进入“我的电脑-》属性-》高级-》性能（设置）-》数据执行保护”，把epoc.exe程序加入例外中就可以了： 假如你想查看nokia模拟器运行日志，可以在运行中打开“%temp%”当前用户临时文件夹，再搜索“epocwind.out”就是了\n","date":"2011-11-28T14:02:21Z","permalink":"https://blog.xenori.com/2011/11/s60emulator-run-terminate/","title":"xp3中运行s60 v3模拟器，出现闪退问题的解决方法"}]